/*++

Copyright (c) Microsoft Corporation. All Rights Reserved

Module Name:

    IddCx.h

Abstract:

    Indirect Displays class extension and the client driver interface.

Environment:

    User-mode Driver Framework

--*/

#ifndef DXVA2_API_DEFINED
#define DXVA2_API_DEFINED
#endif
#ifndef DO_NOT_USE_DIRECTX_OR_DXVA2
#define DO_NOT_USE_DIRECTX_OR_DXVA2
#endif
#include <Opmapi.h>

#include <Dxgi.h>
#include <d3d11_4.h>

//
// NOTE: This header is generated by stubwork.  Please make any 
//       modifications to the corresponding template files 
//       (.x or .y) and use stubwork to regenerate the header
//

#ifndef _IDDCX_H_
#define _IDDCX_H_

#ifndef WDF_EXTERN_C
  #ifdef __cplusplus
    #define WDF_EXTERN_C       extern "C"
    #define WDF_EXTERN_C_START extern "C" {
    #define WDF_EXTERN_C_END   }
  #else
    #define WDF_EXTERN_C
    #define WDF_EXTERN_C_START
    #define WDF_EXTERN_C_END
  #endif
#endif

WDF_EXTERN_C_START



#ifndef WDFAPI
#error Include WDF.H first
#endif

// Disable warning 'nonstandard extension used : nameless struct/union'
#pragma warning(push)
#pragma warning(disable : 4201)

// DDI Version model
// -----------------
// The interface version model will be based on structure versions, when a DDI call/OS callback needs to be updated
// the version of that callback we be incremented along with any structures used, for example if v1 of a call was :
//
//     void SomeDDICall(IDDCX_ADAPTER hOsAdapterContext, IDARG_IN_SOME_DDI* pInArgs);
//
// and the functionality/params needed to be changed then the following would be added:
//
//     void SomeDDICall2(IDDCX_ADAPTER hOsAdapterContext, IDARG_IN_SOME_DDI2* pInArgs);
//
// and the DDI function table structure would be updated to IDDCX_DDI2 which would have SomeDDICall replaced with
// SomeDDICall2.  At the same time a new create interface v2 would be used by a driver

// IDDCX Version model
// -------------------
// In order for drivers to know precisely which version of IddCx the driver is running the driver can call the
// IddCxGetVersion() callback.  This helps if IddCx bug that effect behavior are fixed and released within a given OS release,
// for example if a IddCx bug was fixed in the Windows 10 Creators Update after release and the driver needed to know if the
// IddCx being used had that fix they could use IddCxGetVersion()

#define IDDCX_VERSION_RS3 0x1200
#define IDDCX_VERSION_LATEST IDDCX_VERSION_RS3


// Timeout detection and recovery
// ------------------------------
// The OS will monitor the drivers processing of frames and if it detects the driver is not making forward progress it will
// take action to ensure the desktop is not effected.
// The OS will monitor the driver in two ways :
//
// 1) Ensure that each OS->driver call does not take longer than 10 seconds
// 2) Ensure that a driver reports that it has finished process a given frame within 10 seconds, that is that the driver does
//    not call FinishedProcessingFrame() within 10 seconds of the new frame ready event is triggered
//
// In the event of a timeout being detected then the OS will call the UMDF BugCheck() call which will cause the UMDF host
// process to terminate and restart subject to UMDF device restart policy.

/// <summary>
/// Opaque reference to a WDF indirect display adapter object
/// </summary>
DECLARE_HANDLE(IDDCX_ADAPTER);

/// <summary>
/// Opaque reference to a WDF indirect display monitor object
/// </summary>
DECLARE_HANDLE(IDDCX_MONITOR);

/// <summary>
/// Opaque reference to a WDF indirect display swap-chain object.
/// </summary>
DECLARE_HANDLE(IDDCX_SWAPCHAIN);

/// <summary>
/// Opaque reference to a WDF indirect display OPM output protection context
/// </summary>
DECLARE_HANDLE(IDDCX_OPMCTX);

#pragma region Enum Declarations

/// <summary>
/// Enum used to indicates how a given supported feature is implemented
/// </summary>
enum IDDCX_FEATURE_IMPLEMENTATION : UINT
{
    IDDCX_FEATURE_IMPLEMENTATION_UNINITIALIZED = 0,
    /// <summary>
    /// The feature is not implemented
    /// </summary>
    IDDCX_FEATURE_IMPLEMENTATION_NONE = 1,
    /// <summary>
    /// The feature is implemented and hardware is used in the implementation. For example, the adapter
    /// display pipeline blends the hardware cursor image into the signal sent to the monitor.
    /// </summary>
    IDDCX_FEATURE_IMPLEMENTATION_HARDWARE = 2,
    /// <summary>
    /// The feature is implemented and software is used in the implementation. For example, the driver
    /// support hardware cursor by blending the cursor image into the display pixels as part of the processing.
    /// </summary>
    IDDCX_FEATURE_IMPLEMENTATION_SOFTWARE = 3,
};

/// <summary>
/// Enum used to indicates the link type for transmission of the video data
/// </summary>
enum IDDCX_TRANSMISSION_TYPE : UINT
{
    IDDCX_TRANSMISSION_TYPE_UNINITIALIZED = 0,
    /// <summary>
    /// Video data is being transmitted over wired USB
    /// </summary>
    IDDCX_TRANSMISSION_TYPE_WIRED_USB = 0x1,
    /// <summary>
    /// Video data is being transmitted over wired Miracast link
    /// </summary>
    IDDCX_TRANSMISSION_TYPE_WIRED_MIRACAST = 0x2,
    /// <summary>
    /// Video data is being transmitted over a wired connect not already described
    /// </summary>
    IDDCX_TRANSMISSION_TYPE_WIRED_OTHER = 0x3,
    /// <summary>
    /// Video data is being transmitted over wireless MA-USB
    /// </summary>
    IDDCX_TRANSMISSION_TYPE_WIRELESS_MAUSB = 0x4,
    /// <summary>
    /// Video data is being transmitted over wireless network not using MA-USB but the device
    /// is enumerated on the USB bus
    /// </summary>
    IDDCX_TRANSMISSION_TYPE_WIRELESS_USB_OTHER = 0x5,
    /// <summary>
    /// Video data is being transmitted over a WiFi wireless network
    /// </summary>
    IDDCX_TRANSMISSION_TYPE_WIRELESS_WIFI_OTHER = 0x6,
    /// <summary>
    /// Video data is being transmitted over wireless Miracast link
    /// </summary>
    IDDCX_TRANSMISSION_TYPE_WIRELESS_MIRACAST = 0x7,
    /// <summary>
    /// Video data is being transmitted over a non-WiFi wireless network not described above
    /// </summary>
    IDDCX_TRANSMISSION_TYPE_WIRELESS_OTHER = 0x8,
    /// <summary>
    /// Video data is being transmitted over a link type that is not covered by the above defines
    /// </summary>
    IDDCX_TRANSMISSION_TYPE_OTHER = 0xFFFFFFFF,
};

/// <summary>
/// Specifies boolean flags for an indirect display adapter.
/// </summary>
enum IDDCX_ADAPTER_FLAGS : UINT
{
    IDDCX_ADAPTER_FLAGS_NONE = 0,
    /// <summary>
    /// Indirect display automatically support OS virtual modes, this means mode changes can be
    /// performed seamlessly by OS using DWM scaling on a per frame basis without any display mode
    /// change. The disadvantage of this is that when a smaller desktop mode is used by the user the
    /// desktop image provided to the driver to process will be bigger than the desktop size hence
    /// wasting some encode and transmit bandwidth. This value is used to indicate to the OS that the
    /// smallest possible desktop surface size should be used when the desktop mode is changed.
    /// Typically a solution that has a large processing overhead or limited transmission bandwidth will
    /// use this flag reduce the desktop image size to process as much as possible.Note setting this flag
    /// will result in a mode change each time the desktop resolution is changed.
    /// </summary>
    IDDCX_ADAPTER_FLAGS_USE_SMALLEST_MODE = 1,
    /// <summary>
    /// Indicates if the driver can utilize move regions provided by the OS in addition to dirty rects when
    /// encoding the image.  The driver should only set this to TRUE if it will use the move regions as it does
    /// cost additional resource for the OS to generate these.
    /// If driver sets this to FALSE the OS will convert all move regions in to dirty rects
    /// </summary>
    IDDCX_ADAPTER_FLAGS_CAN_USE_MOVE_REGIONS = 2,
};

/// <summary>
///  Used to describe the monitor description
/// </summary>
enum IDDCX_MONITOR_DESCRIPTION_TYPE : UINT
{
    IDDCX_MONITOR_DESCRIPTION_TYPE_UNINITIALIZED = 0,
    /// <summary>
    /// The monitor description is EDID or no EDID description available
    /// If the monitor has no description then IDDCX_MONITOR_DESCRIPTION_TYPE_EDID shall be used with zero description size
    /// and null pointer for data</summary>
    /// </summary>
    IDDCX_MONITOR_DESCRIPTION_TYPE_EDID = 1,
    /// <summary>
    /// For the monitors with DisplayID and EDID
    /// The monitor description starts with DisplayID followed by EDID without any padding in between
    /// EDID should conatain all available data blocks and shall be present
    /// The call to connect monitor will fail if DisplayID is missing or invalid, or if EDID is missing
    /// </summary>
    IDDCX_MONITOR_DESCRIPTION_TYPE_DISPLAYID_AND_EDID = 2,
};

/// <summary>
/// Used to describe a mode the monitor supports based on the monitor description.
/// </summary>
enum IDDCX_MONITOR_MODE_ORIGIN : UINT
{
    IDDCX_MONITOR_MODE_ORIGIN_UNINITIALIZED = 0,
    /// <summary>
    /// Indicates that the driver added this mode from directly processing the monitor description
    /// </summary>
    IDDCX_MONITOR_MODE_ORIGIN_MONITORDESCRIPTOR = 1,
    /// <summary>
    /// Indicates that the driver did not add this mode as a direct resolution of processing the modes
    /// supported by the monitor but because of separate additional knowledge it has about the monitor
    /// </summary>
    IDDCX_MONITOR_MODE_ORIGIN_DRIVER = 2,
};

/// <summary>
/// Describes why the driver is calling to update the mode list
/// </summary>
enum IDDCX_UPDATE_REASON : UINT
{
    IDDCX_UPDATE_REASON_UNINITIALIZED = 0,
    /// <summary>
    /// The mode list is changing due to power constraints on the host system changed
    /// </summary>
    IDDCX_UPDATE_REASON_POWER_CONSTRAINTS = 1,
    /// <summary>
    /// The mode list is changing due to changes in bandwidth between the system and the indirect display device
    /// </summary>
    IDDCX_UPDATE_REASON_HOST_LINK_BANDWIDTH = 2,
    /// <summary>
    /// The mode list is changing due to changes in bandwidth the indirect display device and the monitor
    /// </summary>
    IDDCX_UPDATE_REASON_DISPLAY_LINK_BANDWIDTH = 3,
    /// <summary>
    /// The mode list is changing due to constraints of the product when in a new configuration
    /// </summary>
    IDDCX_UPDATE_REASON_CONFIGURATION_CONSTRAINTS = 4,
    /// <summary>
    /// The mode list is changing due to another reason not listed above
    /// </summary>
    IDDCX_UPDATE_REASON_OTHER = 5,
};

enum IDDCX_PATH_FLAGS : UINT
{
    IDDCX_PATH_FLAGS_NONE = 0,
    /// <summary>
    /// Indicates if this path has changed
    /// </summary>
    IDDCX_PATH_FLAGS_CHANGED = 1,
    /// <summary>
    /// Indicates if this path is active
    /// </summary>
    IDDCX_PATH_FLAGS_ACTIVE = 2,
};

/// <summary>
/// Describes what type of support a driver has for the given Xor cursor format.
/// If driver cannot support a particular monochrome Xor or color Xor cursor it can use the
/// IDDCX_XOR_CURSOR_SUPPORT_EMULATION value to indicate to the OS that it
/// should use it's Xor emulation algorithm to convert the Xor image to alpha cursor and have the
/// driver accelerate that.  This emulation places a solid border around the cursor image so it
/// can be seen in solid color regions of the screen.  The advantages of this is that is allows
/// the Xor cursor to be hardware accelerated when the adapter cannot support Xor, this is very
/// useful on high latency solutions as this typically allows driver to send the cursor information
/// over a sideband channel to reduce the latency.  The disadvantage is that the user will notice a
/// visual difference due to the emulation.  The recommendation is not to use this on a low latency
/// solution where falling back to software cursor will not impact the mouse latency for the
/// user (<50ms) and will result in a better visible experience.  On a high latency solution where
/// the cursor data can be transmitted independently of the desktop image it is recommended to use
/// this flag to allow hardware cursor and hence lower the mouse movement latency.
/// </summary>
enum IDDCX_XOR_CURSOR_SUPPORT : UINT
{
    IDDCX_XOR_CURSOR_SUPPORT_UNINITIALIZED = 0,
    /// <summary>
    /// Driver does not support this Xor cursor type at all, all cursors of this type will be drawn into the desktop image by
    /// the OS
    /// </summary>
    IDDCX_XOR_CURSOR_SUPPORT_NONE = 1,
    /// <summary>
    /// Driver does support this Xor cursor type
    /// </summary>
    IDDCX_XOR_CURSOR_SUPPORT_FULL = 2,
    /// <summary>
    /// The driver does not support this Xor cursor type but driver wants OS to convert the Xor cursor into a alpha cursor,
    /// see comment above
    /// </summary>
    IDDCX_XOR_CURSOR_SUPPORT_EMULATION = 3,
};

/// <summary>
/// Describes the type of cursor
/// </summary>
enum IDDCX_CURSOR_SHAPE_TYPE : UINT
{
    IDDCX_CURSOR_SHAPE_TYPE_UNINITIALIZED = 0,
    /// <summary>
    /// Indicates this is a masked-color cursor shape
    /// </summary>
    IDDCX_CURSOR_SHAPE_TYPE_MASKED_COLOR = 1,
    /// <summary>
    /// Indicates this is a 32bpp alpha cursor
    /// </summary>
    IDDCX_CURSOR_SHAPE_TYPE_ALPHA = 2,
};

/// <summary>
/// Defines the processing status of the frame
/// </summary>
enum IDDCX_FRAME_STATUS : UINT
{
    IDDCX_FRAME_STATUS_UNINITIALIZED = 0,
    /// <summary>
    /// Indicates that the frame was processed completely and sent to the device
    /// </summary>
    IDDCX_FRAME_STATUS_COMPLETED = 1,
    /// <summary>
    /// Indicates that the driver stopped processing this frame to start on a newer frame, this normally
    /// happens if it is taking a long time to process/transmit the frame
    /// </summary>
    IDDCX_FRAME_STATUS_DROPPED = 2,
    /// <summary>
    /// Indicates that the driver stopped processing this frame because driver hit an internal error
    /// </summary>
    IDDCX_FRAME_STATUS_ERROR = 3,
};

/// <summary>
/// Defines the type of frame processing step
/// </summary>
enum IDDCX_FRAME_STATISTICS_STEP_TYPE : UINT
{
    IDDCX_FRAME_STATISTICS_STEP_TYPE_UNINITIALIZED = 0,
    /// <summary>
    /// Used to mark the start of a color convert operation
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE_COLOR_CONVERT_START = 0x1,
    /// <summary>
    /// Used to mark the end of a color convert operation
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE_COLOR_CONVERT_END = 0x2,
    /// <summary>
    /// Used to mark the start of a encode operation
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE_ENCODE_START = 0x3,
    /// <summary>
    /// Used to mark the end of a encode operation
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE_ENCODE_END = 0x4,
    /// <summary>
    /// Used to mark the start of a encrypt operation
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE_ENCRYPT_START = 0x5,
    /// <summary>
    /// Used to mark the end of a encrypt operation
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE_ENCRYPT_END = 0x6,
    /// <summary>
    /// Used to mark the start of a mux'ing operation
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE_MUX_START = 0x7,
    /// <summary>
    /// Used to mark the end of a mux'ing operation
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE_MUX_END = 0x8,
    /// <summary>
    /// Driver defined processing steps points.
    /// There are 256 single point events defined that the driver can use, each just records a single QPC time
    /// Valid driver values valid 0x100 - 0x1FF
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_1 = 0x100,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_2 = 0x101,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_3 = 0x102,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_4 = 0x103,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_5 = 0x104,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_6 = 0x105,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_7 = 0x106,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_8 = 0x107,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_9 = 0x108,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_10 = 0x109,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_256 = 0x1FF,
    /// <summary>
    /// Driver defined processing step intervals.
    /// There are 256 different intervals each with a start and end point defined.
    /// It is invalid to report either start or end without the other or for the start
    /// step to have a QPC time after the QPC time in the end step
    /// Valid start step values are 0x200 - 0x2FFF
    /// Valid end step values are 0x300 - 0x3FFF
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_START_INTERVAL_1 = 0x200,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_END_INTERVAL_1 = 0x300,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_START_INTERVAL_2 = 0x201,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_END_INTERVAL_2 = 0x301,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_START_INTERVAL_3 = 0x202,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_END_INTERVAL_3 = 0x302,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_START_INTERVAL_256 = 0x2FF,
    IDDCX_FRAME_STATISTICS_STEP_TYPE_DRIVER_DEFINED_END_INTERVAL_256 = 0x3FF,
};

enum IDDCX_FRAME_STATISTICS_FLAGS : UINT
{
    IDDCX_FRAME_STATISTICS_FLAGS_NONE = 0,
    /// <summary>
    /// If set indicates that the driver reduced the color fidelity of the desktop image while processing
    /// and transmitting this frame
    /// </summary>
    IDDCX_FRAME_STATISTICS_FLAGS_REDUCED_COLOR_FIDELITY = 1,
};

/// <summary>
/// The type of gamma ramp being set
/// </summary>
enum IDDCX_GAMMARAMP_TYPE : UINT
{
    IDDCX_GAMMARAMP_TYPE_UNINITIALIZED = 0,
    /// <summary>
    /// The gamma ramp is the default ramp
    /// </summary>
    IDDCX_GAMMARAMP_TYPE_DEFAULT = 1,
    /// <summary>
    /// Indicates that the gamma lookup table contains three arrays, one each for the red, green, and blue color channels.
    /// Each array has 256 16-bit values.
    /// </summary>
    IDDCX_GAMMARAMP_TYPE_RGB256x3x16 = 2,
};



#pragma endregion

// Defines the function table used to indirectly call class extension functions.
typedef VOID (*PFN_IDD_CX)(VOID);
extern PFN_IDD_CX IddFunctions[];

// Forward-declare the driver globals structure, which contains system-defined per-driver data.
typedef struct IDD_DRIVER_GLOBALS IDD_DRIVER_GLOBALS, *PIDD_DRIVER_GLOBALS;

#include "IddCxFuncEnum.h"

#pragma region Forward Declarations

// Structures need to be referenced by the event callbacks
struct IDD_CX_CLIENT_CONFIG;
struct IDDCX_ENDPOINT_VERSION;
struct IDDCX_ENDPOINT_DIAGNOSTIC_INFO;
struct IDDCX_ADAPTER_CAPS;
struct IDARG_IN_ADAPTER_INIT_FINISHED;
struct IDARG_IN_ADAPTER_INIT;
struct IDARG_OUT_ADAPTER_INIT;
struct IDDCX_MONITOR_DESCRIPTION;
struct IDDCX_MONITOR_INFO;
struct IDARG_IN_MONITORCREATE;
struct IDARG_OUT_MONITORCREATE;
struct IDARG_OUT_MONITORARRIVAL;
struct IDDCX_MONITOR_MODE;
struct IDARG_IN_PARSEMONITORDESCRIPTION;
struct IDARG_OUT_PARSEMONITORDESCRIPTION;
struct IDARG_IN_GETDEFAULTDESCRIPTIONMODES;
struct IDARG_OUT_GETDEFAULTDESCRIPTIONMODES;
struct IDDCX_TARGET_MODE;
struct IDARG_IN_QUERYTARGETMODES;
struct IDARG_OUT_QUERYTARGETMODES;
struct IDARG_IN_UPDATEMODES;
struct IDARG_IN_MAXDISPLAYPIPELINERATE;
struct IDDCX_PATH;
struct IDARG_IN_COMMITMODES;
struct IDDCX_CURSOR_CAPS;
struct IDARG_IN_SETUP_HWCURSOR;
struct IDDCX_CURSOR_SHAPE_INFO;
struct IDARG_IN_QUERY_HWCURSOR;
struct IDARG_OUT_QUERY_HWCURSOR;
struct IDARG_IN_SETSWAPCHAIN;
struct IDDCX_METADATA;
struct IDARG_IN_SWAPCHAINSETDEVICE;
struct IDARG_OUT_RELEASEANDACQUIREBUFFER;
struct IDARG_IN_GETDIRTYRECTS;
struct IDARG_OUT_GETDIRTYRECTS;
struct IDDCX_MOVEREGION;
struct IDARG_IN_GETMOVEREGIONS;
struct IDARG_OUT_GETMOVEREGIONS;
struct IDDCX_FRAME_STATISTICS_STEP;
struct IDDCX_FRAME_STATISTICS;
struct IDARG_IN_REPORTFRAMESTATISTICS;
struct IDARG_IN_I2C_TRANSMIT;
struct IDARG_IN_SET_GAMMARAMP;
struct IDARG_IN_I2C_RECEIVE;
struct IDARG_IN_OPM_GET_CERTIFICATE_SIZE;
struct IDARG_OUT_OPM_GET_CERTIFICATE_SIZE;
struct IDARG_IN_OPM_GET_CERTIFICATE;
struct IDARG_IN_OPM_CREATE_PROTECTED_OUTPUT;
struct IDDCX_OPM_GET_RANDOM_NUMBER;
struct IDARG_OUT_OPM_GET_RANDOM_NUMBER;
struct IDDCX_OPM_ENCRYPTED_INITIALIZATION_PARAMETERS;
struct IDARG_IN_OPM_SET_SIGNING_KEY_AND_SEQUENCE_NUMBERS;
struct IDARG_IN_OPM_GET_INFOMATION;
struct IDDCX_OPM_GET_INFO_PARAMETERS;
struct IDDCX_OPM_REQUESTED_INFORMATION;
struct IDARG_OUT_OPM_GET_INFOMATION;
struct IDDCX_OPM_CONFIGURE_PARAMETERS;
struct IDARG_IN_OPM_CONFIGURE_PROTECTED_OUTPUT;
struct IDARG_OUT_GETVERSION;
struct IDARG_IN_REPORTCRITICALERROR;
struct IDARG_IN_SETSRMLIST;
struct IDARG_IN_GETSRMLISTVERSION;
struct IDARG_OUT_GETSRMLISTVERSION;

#pragma endregion

#pragma region Driver Callback Definitions

#pragma region Device Callbacks

/// <summary>
/// Driver DDI function that is called by the OS when an IO control request needs processing by the driver.
/// </summary>
typedef
_Function_class_(EVT_IDD_CX_DEVICE_IO_CONTROL)
_IRQL_requires_same_
VOID
EVT_IDD_CX_DEVICE_IO_CONTROL(
    _In_
    WDFDEVICE Device,
    _In_
    WDFREQUEST Request,
    _In_
    size_t OutputBufferLength,
    _In_
    size_t InputBufferLength,
    _In_
    ULONG IoControlCode
    );

typedef EVT_IDD_CX_DEVICE_IO_CONTROL *PFN_IDD_CX_DEVICE_IO_CONTROL;

/// <summary>
///  A driver DDI function that OS calls to request the driver to parse a monitor description into a list of modes
/// the monitor supports
/// </summary>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_PARSE_MONITOR_DESCRIPTION)
_IRQL_requires_same_
NTSTATUS
EVT_IDD_CX_PARSE_MONITOR_DESCRIPTION(
    _In_
    const IDARG_IN_PARSEMONITORDESCRIPTION* pInArgs,
    _Out_
    IDARG_OUT_PARSEMONITORDESCRIPTION* pOutArgs
    );

typedef EVT_IDD_CX_PARSE_MONITOR_DESCRIPTION *PFN_IDD_CX_PARSE_MONITOR_DESCRIPTION;

#pragma endregion

#pragma region Adapter Callbacks

/// <summary>
/// A driver DDI that is called by the OS to inform the driver that the adapter initialization has completed. The
/// initialization may have failed, so the driver should check the parameters for the adapter status and handle
/// failures appropriately (possibly by reporting a device failure).
/// </summary>
typedef
_Function_class_(EVT_IDD_CX_ADAPTER_INIT_FINISHED)
_IRQL_requires_same_
NTSTATUS
EVT_IDD_CX_ADAPTER_INIT_FINISHED(
    _In_
    IDDCX_ADAPTER AdapterObject,
    _In_
    const IDARG_IN_ADAPTER_INIT_FINISHED* pInArgs
    );

typedef EVT_IDD_CX_ADAPTER_INIT_FINISHED *PFN_IDD_CX_ADAPTER_INIT_FINISHED;

/// <summary>
/// A driver DDI that is called by OS to inform the driver of a mode change for monitors on the adapter.
/// The OS always provides the IDDCX_PATH for every connected monitor even if it is not active and the OS
/// indicates which paths have changed.  If a path is marked not active then we expect that whole display pipeline for
/// that path to be powered off and no signal is sent to the monitor
///
/// NOTE : When a new path is committed the driver should program the display pipeline to display a black
/// image until the first frame is ready to be displayed(ie WDDM visibility should be off until
/// first frame is ready to be displayed and then the visibility should be turned on).
/// </summary>
/// <param name="hDriverAdapterContext">The handle the driver provides so the OS can reference the adapter when calling the driver</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_ADAPTER_COMMIT_MODES)
_IRQL_requires_same_
NTSTATUS
EVT_IDD_CX_ADAPTER_COMMIT_MODES(
    _In_
    IDDCX_ADAPTER AdapterObject,
    _In_
    const IDARG_IN_COMMITMODES* pInArgs
    );

typedef EVT_IDD_CX_ADAPTER_COMMIT_MODES *PFN_IDD_CX_ADAPTER_COMMIT_MODES;

#pragma endregion

#pragma region Monitor Callbacks

/// <summary>
/// A driver DDI function that OS calls to request the driver provide the default monitor mode list for the
/// specified monitor. This DDI is called when a monitor without a description is connected.
/// </summary>
/// <param name="MonitorObject">The monitor object that is having default modes generated</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
/// <remarks>
/// The driver must create at least one monitor mode for the monitor description.
/// </remarks>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_GET_DEFAULT_DESCRIPTION_MODES)
_IRQL_requires_same_
NTSTATUS
EVT_IDD_CX_MONITOR_GET_DEFAULT_DESCRIPTION_MODES(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    const IDARG_IN_GETDEFAULTDESCRIPTIONMODES* pInArgs,
    _Out_
    IDARG_OUT_GETDEFAULTDESCRIPTIONMODES* pOutArgs
    );

typedef EVT_IDD_CX_MONITOR_GET_DEFAULT_DESCRIPTION_MODES *PFN_IDD_CX_MONITOR_GET_DEFAULT_DESCRIPTION_MODES;

/// <summary>
/// A driver DDI function that OS calls to get a list of target modes supported by the driver for a monitor
/// connected to the endpoint.
/// </summary>
/// <param name="MonitorObject">The monitor object whose modes are being queried</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_QUERY_TARGET_MODES)
_IRQL_requires_same_
NTSTATUS
EVT_IDD_CX_MONITOR_QUERY_TARGET_MODES(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    const IDARG_IN_QUERYTARGETMODES* pInArgs,
    _Out_
    IDARG_OUT_QUERYTARGETMODES* pOutArgs
    );

typedef EVT_IDD_CX_MONITOR_QUERY_TARGET_MODES *PFN_IDD_CX_MONITOR_QUERY_TARGET_MODES;

/// <summary>
/// Driver DDI function that is called by OS inform the driver of a mode change for monitors on the adapter.
///
/// NOTE : The resolution of the surfaces in the swapchain will always be the same resolution as the target mode set and
///        format will be one of the formats supported by the driver but the format of each acquired buffer may
///        change frame to frame between the formats supported and the driver should check the format of each buffer acquired.
/// </summary>
/// <param name="hDriverAdapterContext">The handle the driver provides so the OS can reference the adapter when calling the driver</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_ASSIGN_SWAPCHAIN)
_IRQL_requires_same_
NTSTATUS
EVT_IDD_CX_MONITOR_ASSIGN_SWAPCHAIN(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    const IDARG_IN_SETSWAPCHAIN* pInArgs
    );

typedef EVT_IDD_CX_MONITOR_ASSIGN_SWAPCHAIN *PFN_IDD_CX_MONITOR_ASSIGN_SWAPCHAIN;

/// <summary>
/// Driver DDI function that is called by OS inform the driver that a swapchain associated with a monitor is not
/// valid anymore
/// </summary>
/// <param name="MonitorObject">The monitor whose swap-chain is no longer valid.</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_UNASSIGN_SWAPCHAIN)
_IRQL_requires_same_
NTSTATUS
EVT_IDD_CX_MONITOR_UNASSIGN_SWAPCHAIN(
    _In_
    IDDCX_MONITOR MonitorObject
    );

typedef EVT_IDD_CX_MONITOR_UNASSIGN_SWAPCHAIN *PFN_IDD_CX_MONITOR_UNASSIGN_SWAPCHAIN;

/// <summary>
/// Driver DDI function that is called by OS to returns data received from an I2C device in a monitor
/// </summary>
/// <param name="MonitorObject">A handle to monitor object to send I2C data.</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
/// <remarks>
/// The data is transmitted to an I2C device in the monitor that is connected to path specified by PathIdx
/// I2CTransmitDataToDisplay is responsible for signaling the I2C start condition, sending the I2C address, sending the
/// data in the buffer, checking for acknowledgments from the receiver, and signaling the stop condition.For details
/// about the I2C bus, see the I2C Bus Specification, published by Philips Semiconductors.The specification defines a
/// protocol for initiating I2C communication, reading and writing bytes over the I2C data line, and terminating I2C
/// communication.
///
/// I2CTransmitDataToDisplay is required to transmit data to an I2C device that has address 0x6E but is permitted to
/// refuse to transmit data to any I2C device that has a different address.
///
/// I2CTransmitDataToDisplay is permitted to block if another part of the display driver or graphics hardware is using
/// the specified monitor's I2C bus. It is also permitted to block if the display driver is using the I2C bus to send or
/// receive High-bandwidth Digital Content Protection (HDCP) data.
///
/// If the display adapter supports HDCP, the I2CTransmitDataToDisplay function must refuse to send data to an I2C device
/// if the device has an I2C address that is used by HDCP.
///
/// I2CTransmitDataToDisplay must never transmit data to an I2C device on the display adapter.That is, this function can
/// transmit data to an I2C device in a monitor that is connected to the display adapter, but not to an I2C device that
/// is on the display adapter itself.
/// </remarks>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_I2C_TRANSMIT)
_IRQL_requires_same_
NTSTATUS
EVT_IDD_CX_MONITOR_I2C_TRANSMIT(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    const IDARG_IN_I2C_TRANSMIT* pInArgs
    );

typedef EVT_IDD_CX_MONITOR_I2C_TRANSMIT *PFN_IDD_CX_MONITOR_I2C_TRANSMIT;

/// <summary>
/// Driver DDI function that is called by OS to returns data received from an I2C device in a monitor
/// </summary>
/// <param name="MonitorObject">A handle to monitor object to receive I2C data from.</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
/// <remarks>
/// The data is received from an I2C device in the monitor that is connected to path specified by PathIdx
/// I2CReceiveDataFromDisplay function is responsible for signaling the I2C start condition, sending the I2C address,
/// receiving the data from the I2C device, sending acknowledgments, and signaling the stop condition.
/// For details about the I2C bus, see the I2C Bus Specification, published by Philips Semiconductors.
/// The specification defines a protocol for initiating I2C communication, reading and writing bytes over the I2C data
/// line, and terminating I2C communication. (This resource may not be available in some languages and countries.)
///
/// I2CReceiveDataFromDisplay is required to receive data from an I2C device that has address 0x6F but is
/// permitted to refuse to receive data from any I2C device that has a different address.
///
/// I2CReceiveDataFromDisplay is permitted to block if another part of the display driver or graphics hardware is
/// using the specified monitor's I2C bus. It is also permitted to block if the display driver is using the I2C
/// bus to send or receive High-bandwidth Digital Content Protection (HDCP) data.
///
/// If the display adapter supports HDCP, I2CReceiveDataFromDisplay must refuse to receive data from an I2C device if the
/// device has an I2C address that is used by HDCP.
///
/// I2CReceiveDataFromDisplay must never receive data from an I2C device on the display adapter.That is, this function
/// can receive data from an I2C device in a monitor that is connected to the display adapter, but not from an I2C
/// device that is on the display adapter itself.
/// </remarks>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_I2C_RECEIVE)
_IRQL_requires_same_
NTSTATUS
EVT_IDD_CX_MONITOR_I2C_RECEIVE(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    const IDARG_IN_I2C_RECEIVE* pInArgs
    );

typedef EVT_IDD_CX_MONITOR_I2C_RECEIVE *PFN_IDD_CX_MONITOR_I2C_RECEIVE;

/// <summary>
/// Driver DDI function that is called by OS to set a gamma ramp on the specified monitor
/// </summary>
/// <param name="MonitorObject">This is the context for the monitor this gamma call is intended for</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
/// <remarks>
/// If the driver implements this DDI then this implies the driver support the gamma functionality
/// </remarks>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_SET_GAMMA_RAMP)
_IRQL_requires_same_
NTSTATUS
EVT_IDD_CX_MONITOR_SET_GAMMA_RAMP(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    const IDARG_IN_SET_GAMMARAMP* pInArgs
    );

typedef EVT_IDD_CX_MONITOR_SET_GAMMA_RAMP *PFN_IDD_CX_MONITOR_SET_GAMMA_RAMP;

/// <summary>
/// Driver DDI function that is called by OS to get the size of a OPM certificate
/// </summary>
/// <param name="AdapterObject">This is the context for the adapter this OPM call is intended for</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_OPM_GET_CERTIFICATE_SIZE)
_IRQL_requires_same_
NTSTATUS
EVT_IDD_CX_MONITOR_OPM_GET_CERTIFICATE_SIZE(
    _In_
    IDDCX_ADAPTER AdapterObject,
    _In_
    const IDARG_IN_OPM_GET_CERTIFICATE_SIZE* pInArgs,
    _Out_
    IDARG_OUT_OPM_GET_CERTIFICATE_SIZE* pOutArgs
    );

typedef EVT_IDD_CX_MONITOR_OPM_GET_CERTIFICATE_SIZE *PFN_IDD_CX_MONITOR_OPM_GET_CERTIFICATE_SIZE;

/// <summary>
/// Driver DDI function that is called by OS to get a OPM certificate
/// </summary>
/// <param name="AdapterObject">This is the context for the adapter this OPM call is intended for</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_OPM_GET_CERTIFICATE)
_IRQL_requires_same_
NTSTATUS
EVT_IDD_CX_MONITOR_OPM_GET_CERTIFICATE(
    _In_
    IDDCX_ADAPTER AdapterObject,
    _In_
    const IDARG_IN_OPM_GET_CERTIFICATE* pInArgs
    );

typedef EVT_IDD_CX_MONITOR_OPM_GET_CERTIFICATE *PFN_IDD_CX_MONITOR_OPM_GET_CERTIFICATE;

/// <summary>
/// Driver DDI function that is called by OS to create a OPM protected output context
/// </summary>
/// <param name="MonitorObject">This is the context for the monitor this OPM context should be created on
/// <param name="OpmCxtObject">This is the context for the OPM context this call is for</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_OPM_CREATE_PROTECTED_OUTPUT)
_IRQL_requires_same_
NTSTATUS
EVT_IDD_CX_MONITOR_OPM_CREATE_PROTECTED_OUTPUT(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    IDDCX_OPMCTX OpmCxtObject,
    _In_
    const IDARG_IN_OPM_CREATE_PROTECTED_OUTPUT* pInArgs
    );

typedef EVT_IDD_CX_MONITOR_OPM_CREATE_PROTECTED_OUTPUT *PFN_IDD_CX_MONITOR_OPM_CREATE_PROTECTED_OUTPUT;

/// <summary>
/// Driver DDI function that is called by OS get a OPM random number
/// </summary>
/// <param name="OpmCxtObject">This is the context for the OPM context this call is for</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_OPM_GET_RANDOM_NUMBER)
_IRQL_requires_same_
NTSTATUS
EVT_IDD_CX_MONITOR_OPM_GET_RANDOM_NUMBER(
    _In_
    IDDCX_OPMCTX OpmCxtObject,
    _Out_
    IDARG_OUT_OPM_GET_RANDOM_NUMBER* pOutArgs
    );

typedef EVT_IDD_CX_MONITOR_OPM_GET_RANDOM_NUMBER *PFN_IDD_CX_MONITOR_OPM_GET_RANDOM_NUMBER;

/// <summary>
/// Driver DDI function that is called by OS to set signing key and sequence number
/// </summary>
/// <param name="OpmCxtObject">This is the context for the OPM context this call is for</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_OPM_SET_SIGNING_KEY_AND_SEQUENCE_NUMBERS)
_IRQL_requires_same_
NTSTATUS
EVT_IDD_CX_MONITOR_OPM_SET_SIGNING_KEY_AND_SEQUENCE_NUMBERS(
    _In_
    IDDCX_OPMCTX OpmCxtObject,
    _In_
    const IDARG_IN_OPM_SET_SIGNING_KEY_AND_SEQUENCE_NUMBERS* pInArgs
    );

typedef EVT_IDD_CX_MONITOR_OPM_SET_SIGNING_KEY_AND_SEQUENCE_NUMBERS *PFN_IDD_CX_MONITOR_OPM_SET_SIGNING_KEY_AND_SEQUENCE_NUMBERS;

/// <summary>
/// Driver DDI function that is called by OS to get OPM information
/// </summary>
/// <param name="OpmCxtObject">This is the context for the OPM context this call is for</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_OPM_GET_INFOMATION)
_IRQL_requires_same_
NTSTATUS
EVT_IDD_CX_MONITOR_OPM_GET_INFOMATION(
    _In_
    IDDCX_OPMCTX OpmCxtObject,
    _In_
    const IDARG_IN_OPM_GET_INFOMATION* pInArgs,
    _Out_
    IDARG_OUT_OPM_GET_INFOMATION* pOutArgs
    );

typedef EVT_IDD_CX_MONITOR_OPM_GET_INFOMATION *PFN_IDD_CX_MONITOR_OPM_GET_INFOMATION;

/// <summary>
/// Driver DDI function that is called by OS to configure the protected output
/// </summary>
/// <param name="OpmCxtObject">This is the context for the OPM context this call is for</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_OPM_CONFIGURE_PROTECTED_OUTPUT)
_IRQL_requires_same_
NTSTATUS
EVT_IDD_CX_MONITOR_OPM_CONFIGURE_PROTECTED_OUTPUT(
    _In_
    IDDCX_OPMCTX OpmCxtObject,
    _In_
    const IDARG_IN_OPM_CONFIGURE_PROTECTED_OUTPUT* pInArgs
    );

typedef EVT_IDD_CX_MONITOR_OPM_CONFIGURE_PROTECTED_OUTPUT *PFN_IDD_CX_MONITOR_OPM_CONFIGURE_PROTECTED_OUTPUT;

/// <summary>
/// Driver DDI function that is called by OS destroy the protected output context
/// </summary>
/// <param name="OpmCxtObject">This is the context for the OPM context this call is for</param>
/// <returns>If the routine succeeds it return STATUS_SUCCESS otherwise an appropriate error code</returns>
typedef
_Function_class_(EVT_IDD_CX_MONITOR_OPM_DESTROY_PROTECTED_OUTPUT)
_IRQL_requires_same_
NTSTATUS
EVT_IDD_CX_MONITOR_OPM_DESTROY_PROTECTED_OUTPUT(
    _In_
    IDDCX_OPMCTX OpmCxtObject
    );

typedef EVT_IDD_CX_MONITOR_OPM_DESTROY_PROTECTED_OUTPUT *PFN_IDD_CX_MONITOR_OPM_DESTROY_PROTECTED_OUTPUT;

#pragma endregion

#pragma endregion

#pragma region Structure Definitions

/// <summary>
/// Holds per-driver Indirect Display information. Reserved for use by the system.
/// </summary>
typedef struct IDD_DRIVER_GLOBALS
{
    ULONG Reserved;
} IDD_DRIVER_GLOBALS, *PIDD_DRIVER_GLOBALS;

/// <summary>
/// Contains information and callbacks for WDFDEVICE intitialization using the Indirect Display class extension.
/// </summary>
struct IDD_CX_CLIENT_CONFIG
{
    /// <summary>
    /// The total size of the structure.
    /// </summary>
    ULONG Size;

    PFN_IDD_CX_DEVICE_IO_CONTROL EvtIddCxDeviceIoControl;
    PFN_IDD_CX_PARSE_MONITOR_DESCRIPTION EvtIddCxParseMonitorDescription;

    PFN_IDD_CX_ADAPTER_INIT_FINISHED EvtIddCxAdapterInitFinished;
    PFN_IDD_CX_ADAPTER_COMMIT_MODES EvtIddCxAdapterCommitModes;

    PFN_IDD_CX_MONITOR_GET_DEFAULT_DESCRIPTION_MODES EvtIddCxMonitorGetDefaultDescriptionModes;
    PFN_IDD_CX_MONITOR_QUERY_TARGET_MODES EvtIddCxMonitorQueryTargetModes;
    PFN_IDD_CX_MONITOR_ASSIGN_SWAPCHAIN EvtIddCxMonitorAssignSwapChain;
    PFN_IDD_CX_MONITOR_UNASSIGN_SWAPCHAIN EvtIddCxMonitorUnassignSwapChain;
    PFN_IDD_CX_MONITOR_I2C_TRANSMIT EvtIddCxMonitorI2CTransmit;
    PFN_IDD_CX_MONITOR_I2C_RECEIVE EvtIddCxMonitorI2CReceive;
    PFN_IDD_CX_MONITOR_SET_GAMMA_RAMP EvtIddCxMonitorSetGammaRamp;

    PFN_IDD_CX_MONITOR_OPM_GET_CERTIFICATE_SIZE EvtIddCxMonitorOPMGetCertificateSize;
    PFN_IDD_CX_MONITOR_OPM_GET_CERTIFICATE EvtIddCxMonitorOPMGetCertificate;
    PFN_IDD_CX_MONITOR_OPM_CREATE_PROTECTED_OUTPUT EvtIddCxMonitorOPMCreateProtectedOutput;
    PFN_IDD_CX_MONITOR_OPM_GET_RANDOM_NUMBER EvtIddCxMonitorOPMGetRandomNumber;
    PFN_IDD_CX_MONITOR_OPM_SET_SIGNING_KEY_AND_SEQUENCE_NUMBERS EvtIddCxMonitorOPMSetSigningKeyAndSequenceNumbers;
    PFN_IDD_CX_MONITOR_OPM_GET_INFOMATION EvtIddCxMonitorOPMGetInformation;
    PFN_IDD_CX_MONITOR_OPM_CONFIGURE_PROTECTED_OUTPUT EvtIddCxMonitorOPMConfigureProtectedOutput;
    PFN_IDD_CX_MONITOR_OPM_DESTROY_PROTECTED_OUTPUT EvtIddCxMonitorOPMDestroyProtectedOutput;
};

/// <summary>
/// Structure used to describe a version
/// </summary>
struct IDDCX_ENDPOINT_VERSION
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// The major version defined by the driver
    /// </summary>
    UINT MajorVer;

    /// <summary>
    /// The minor version defined by the driver
    /// </summary>
    UINT MinorVer;

    /// <summary>
    /// The build number defined by the driver
    /// </summary>
    UINT Build;

    /// <summary>
    /// The SKU type defined by the driver
    /// </summary>
    UINT64 SKU;
};

/// <summary>
/// Structure used to provide diagnostics information about an endpoint
/// </summary>
struct IDDCX_ENDPOINT_DIAGNOSTIC_INFO
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// Describes the type of link the video data is being transmitted over
    /// </summary>
    IDDCX_TRANSMISSION_TYPE TransmissionType;

    /// <summary>
    /// The friendly name of the endpoint if one exists, this is applicable if the user can give the device
    /// a name, should be NULL if friendly name does not exist
    /// </summary>
    PCWSTR pEndPointFriendlyName;

    /// <summary>
    /// The model name of the endpoint, must be a non - empty string
    /// </summary>
    PCWSTR pEndPointModelName;

    /// <summary>
    /// The manufacture name of the endpoint, must be a non - empty string
    /// </summary>
    PCWSTR pEndPointManufacturerName;

    /// <summary>
    /// Pointer to version info for the endpoint hardware
    /// </summary>
    IDDCX_ENDPOINT_VERSION* pHardwareVersion;

    /// <summary>
    /// Pointer to version info for the endpoint hardware
    /// </summary>
    IDDCX_ENDPOINT_VERSION* pFirmwareVersion;

    /// <summary>
    /// Indicates how gamma is implemented
    /// </summary>
    IDDCX_FEATURE_IMPLEMENTATION GammaSupport;
};

/// <summary>
/// Used to define the capabilities of an adapter
/// </summary>
struct IDDCX_ADAPTER_CAPS
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    IDDCX_ADAPTER_FLAGS Flags;

    /// <summary>
    /// This value represents the total display bandwidth for the adapter, each mode the driver reports to
    /// the OS also has a display pipeline rate associated with it and the OS will ensure that the combined
    /// display pipeline rate of all the active modes will never exceed this value. The units the driver uses
    /// is up to the driver.
    /// </summary>
    UINT64 MaxDisplayPipelineRate;

    /// <summary>
    /// Indicates the maximum number of monitors that can be connected at the same time
    /// </summary>
    UINT MaxMonitorsSupported;

    /// <summary>
    /// Endpoint diagnostics information, none of this is used for runtime OS decision but used for telemetry
    /// </summary>
    IDDCX_ENDPOINT_DIAGNOSTIC_INFO EndPointDiagnostics;

    /// <summary>
    /// The number of frames to request after the desktop goes idle if the driver's encoder requires multiple frames
    /// to continue improving quality.
    /// </summary>
    UINT StaticDesktopReencodeFrameCount;
};

struct IDARG_IN_ADAPTER_INIT
{
    /// <summary>
    /// The device that will be hosting this WDDM adapter object.
    /// </summary>
    WDFDEVICE WdfDevice;

    /// <summary>
    /// [in] Adapter capabilities
    /// </summary>
    IDDCX_ADAPTER_CAPS* pCaps;

    /// <summary>
    /// [in, optional] Object attributes that are used to initialize the WDF adapter object.
    /// </summary>
    PWDF_OBJECT_ATTRIBUTES ObjectAttributes;
};

struct IDARG_OUT_ADAPTER_INIT
{
    /// <summary>
    /// [out] Handle to the adapter that the driver can use to identify this adapter when calling OS functions.
    /// </summary>
    IDDCX_ADAPTER AdapterObject;
};

struct IDARG_IN_ADAPTER_INIT_FINISHED
{
    NTSTATUS AdapterInitStatus;
};

struct IDDCX_MONITOR_DESCRIPTION
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// Type of this monitor description
    /// </summary>
    IDDCX_MONITOR_DESCRIPTION_TYPE Type;

    /// <summary>
    /// The size of the monitor description data
    /// </summary>
    UINT DataSize;

    /// <summary>
    /// Pointer to the monitor description data
    /// Depending on the Type it can be either EDID or DisplayID + EDID
    /// Reference IDDCX_MONITOR_DESCRIPTION_TYPE for more information
    /// </summary>
    _Field_size_full_(DataSize) PVOID pData;
};

/// <summary>
/// Used to specify information about a monitor
/// </summary>
struct IDDCX_MONITOR_INFO
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// The is the monitor connector type of the monitor
    /// </summary>
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY MonitorType;

    /// <summary>
    /// This is a zero based unique identifier for this connector, it should be unique for this adapter and the value should
    /// not change for this connector across system reboot or driver upgrade.
    /// The value has to be between 0 and (IDDCX_ADAPTER_CAPS.MaxMonitorsSupported-1)
    /// </summary>
    UINT ConnectorIndex;

    /// <summary>
    /// Pointer the monitor description for the monitor, if the monitor does not have any description data this should be set to NULL
    /// </summary>
    IDDCX_MONITOR_DESCRIPTION MonitorDescription;

    /// <summary>
    /// Container Id of the monitor being connected, if any device is also inside the monitor (eg audio, touch etc) then
    /// those device should all have the same container id.
    /// </summary>
    GUID MonitorContainerId;
};

struct IDARG_IN_MONITORCREATE
{
    PWDF_OBJECT_ATTRIBUTES ObjectAttributes;

    /// <summary>
    /// [in] Pointer to the information about this monitor
    /// </summary>
    IDDCX_MONITOR_INFO* pMonitorInfo;
};

struct IDARG_OUT_MONITORCREATE
{
    /// <summary>
    /// [out] Handle the driver can use to identify this monitor when calling OS functions
    /// </summary>
    IDDCX_MONITOR MonitorObject;
};

struct IDARG_OUT_MONITORARRIVAL
{
    /// <summary>
    /// Luid of the adapter where this monitor is exposed to the OS
    /// NOTE : There are no API/DDI calls the driver can do with this info it's only use is to pass to companion
    /// applications so they can identify the monitor they control
    /// </summary>
    LUID OsAdapterLuid;

    /// <summary>
    /// DMM VidPn target id of the target this monitor is exposed to the OS
    /// NOTE : There are no API/DDI calls the driver can do with this info it's only use is to pass to companion
    /// applications so they can identify the monitor they control
    /// NOTE : Although this value is related to the IDDCX_MONITOR_INFO.ConnectorIndex passed by the driver
    /// the OS will perform internal mapping between the two that will change is future release so the driver should not take
    /// any dependences on this mapping and hence should use OsAdapterLuid & OsTargetId and not IDDCX_MONITOR_INFO.ConnectorIndex
    /// </summary>
    UINT OsTargetId;
};

struct IDDCX_MONITOR_MODE
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// Where the driver derived this mode from
    /// </summary>
    IDDCX_MONITOR_MODE_ORIGIN Origin;

    /// <summary>
    /// This is the details of the Monitor mode.Note that AdditionalSignalInfo.vSyncFreqDivider has to have a zero value
    /// </summary>
    DISPLAYCONFIG_VIDEO_SIGNAL_INFO MonitorVideoSignalInfo;
};

struct IDARG_IN_PARSEMONITORDESCRIPTION
{
    /// <summary>
    /// [in] Monitor description the driver should decode
    /// </summary>
    IDDCX_MONITOR_DESCRIPTION MonitorDescription;

    /// <summary>
    /// [in] The number of monitor modes the pMonitorModes buffer being passed into the driver can hold.
    /// A value of zero indicates that the driver should not copy the monitor mode list
    /// into the provide buffer but should set the output buffer size to the size required
    /// </summary>
    UINT MonitorModeBufferInputCount;

    /// <summary>
    /// [out] Pointer to buffer that driver should copy the monitor modes to if the value is non-NULL.
    /// If value is NULL then driver should not copy any data and should just set the value
    /// IDARG_OUT_PARSEMONITORDESCRIPTION.MonitorModeBufferOutputCount to indicate the size of buffer
    /// required to store the modes
    /// </summary>
    _Field_size_opt_(MonitorModeBufferInputCount) IDDCX_MONITOR_MODE* pMonitorModes;
};

#define NO_PREFERRED_MODE 0xffffffff

struct IDARG_OUT_PARSEMONITORDESCRIPTION
{
    /// <summary>
    /// [out] If IDARG_IN_PARSEMONITORDESCRIPTION.pMonitorModes was NULL then driver should
    /// set this to the number of monitor modes the driver would generate for the specified monitor
    /// description.
    /// If IDARG_IN_PARSEMONITORDESCRIPTION.pMonitorModes was non-NULL then this is the count of the
    /// monitor modes that the driver copied to that buffer
    /// </summary>
    UINT MonitorModeBufferOutputCount;

    /// <summary>
    /// [out] Index into the pMonitorModes array of the preferred mode monitor mode, a value of NO_PREFERRED_MODE
    /// indicates that there is no preferred monitor mode
    /// </summary>
    UINT PreferredMonitorModeIdx;
};

struct IDARG_IN_GETDEFAULTDESCRIPTIONMODES
{
    /// <summary>
    /// [in] The number of monitor modes the pDefaultsMonitorModes buffer being passed into the driver can hold.
    /// A value of zero indicates that the driver should not copy the monitor mode list
    /// into the provide buffer but should set the output buffer size to the size required
    /// </summary>
    UINT DefaultMonitorModeBufferInputCount;

    /// <summary>
    /// [out] Pointer to buffer that driver should copy the monitor modes to if the value is non-NULL.
    /// If value is NULL then driver should not copy any data and should just set the value
    /// IDARG_OUT_GETDEFAULTDESCRIPTIONMODES.DefaultMonitorModeBufferOutputCount to indicate the size of buffer
    /// required to store the modes
    /// </summary>
    _Field_size_opt_(DefaultMonitorModeBufferInputCount) IDDCX_MONITOR_MODE* pDefaultMonitorModes;
};

struct IDARG_OUT_GETDEFAULTDESCRIPTIONMODES
{
    /// <summary>
    /// [out] If IDARG_IN_PARSEMONITORDESCRIPTION.pDefaultMonitorModes was NULL then driver should
    /// set this to the number of monitor modes the driver would generate for the specified monitor
    /// description.
    /// If IDARG_IN_PARSEMONITORDESCRIPTION.pDefaultMonitorModes was non-NULL then this is the count of the
    /// monitor modes that the driver copied to that buffer
    /// </summary>
    UINT DefaultMonitorModeBufferOutputCount;

    /// <summary>
    /// [out] Index into the pMonitorModes array of the preferred mode monitor mode, a value of NO_PREFERRED_MODE
    /// indicates that there is no preferred monitor mode
    /// </summary>
    UINT PreferredMonitorModeIdx;
};

/// <summary>
/// Used to describe a target mode
/// </summary>
struct IDDCX_TARGET_MODE
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// This is the details of the target mode.Note that AdditionalSignalInfo.vSyncFreqDivider has to have a zero value
    /// NOTE : DISPLAYCONFIG_VIDEO_SIGNAL_INFO.vSyncFreq is the Vsync rate between the Indirect Display device and the
    /// connected monitor.  DISPLAYCONFIG_VIDEO_SIGNAL_INFO.AdditionalSignalInfo.vSyncFreqDivider is used to
    /// calculate the rate at which the OS will update the desktop image.
    /// The desktop update rate will calculate be :
    ///    DISPLAYCONFIG_VIDEO_SIGNAL_INFO.vSyncFreq / DISPLAYCONFIG_VIDEO_SIGNAL_INFO.AdditionalSignalInfo.vSyncFreqDivider
    /// DISPLAYCONFIG_VIDEO_SIGNAL_INFO.AdditionalSignalInfo.vSyncFreqDivider cannot be zero
    /// </summary>
    DISPLAYCONFIG_TARGET_MODE TargetVideoSignalInfo;

    /// <summary>
    /// This is the display pipeline bandwidth required for this mode.
    /// </summary>
    UINT64 RequiredBandwidth;
};

struct IDARG_IN_QUERYTARGETMODES
{
    /// <summary>
    /// [in] The monitor description, note this may not be the monitor description the driver originally
    /// provided in the monitor arrival call, the driver needs to use this monitor description
    /// when processing this DDI. This allows for monitor description to be updated by OS.
    /// </summary>
    IDDCX_MONITOR_DESCRIPTION MonitorDescription;

    /// <summary>
    /// [in] The number of target modes the pTargetModes buffer be passed to the driver can hold.
    /// If the value is zero then the driver should not copy the target mode list to pTargetModes
    /// </summary>
    UINT TargetModeBufferInputCount;

    /// <summary>
    /// [out] Pointer to buffer driver should copy the target modes it supports for this monitor
    /// </summary>
    _Field_size_(TargetModeBufferInputCount) IDDCX_TARGET_MODE* pTargetModes;
};

struct IDARG_OUT_QUERYTARGETMODES
{
    /// <summary>
    /// [out] Driver should set this to the number of target modes the driver copied to the buffer
    /// if the OS provided one otherwise the number of target modes it would have copied if the OS
    /// had provided a buffer
    /// </summary>
    UINT TargetModeBufferOutputCount;
};

struct IDARG_IN_UPDATEMODES
{
    /// <summary>
    /// Indicates the reason why the driver is updating the modes
    /// </summary>
    IDDCX_UPDATE_REASON Reason;

    /// <summary>
    /// [in] Number of target modes in the pTargetModes buffer.  This cannot be zero
    /// </summary>
    UINT TargetModeCount;

    /// <summary>
    /// [in] Pointer to buffer driver should copy the target modes it supports for this monitor
    /// </summary>
    _Field_size_(TargetModeCount) IDDCX_TARGET_MODE* pTargetModes;
};

struct IDARG_IN_MAXDISPLAYPIPELINERATE
{
    /// <summary>
    /// Indicates the reason why the driver is updating the rate
    /// </summary>
    IDDCX_UPDATE_REASON Reason;

    /// <summary>
    /// This is the new value for IDDCX_ADAPTER_CAPS.MaxDisplayPipelineRate
    /// </summary>
    UINT64 MaxDisplayPipelineRate;
};

/// <summary>
/// Used to describe the mode that should be set on a given monitor
/// </summary>
struct IDDCX_PATH
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// The handle the driver provides to identify the monitor this path is targeted at
    /// </summary>
    IDDCX_MONITOR MonitorObject;

    /// <summary>
    /// Contains flags for this path, like the path's active state and whether it changed.
    /// </summary>
    IDDCX_PATH_FLAGS Flags;

    /// <summary>
    /// This is the details of the target mode.Note that AdditionalSignalInfo.vSyncFreqDivider has to have a zero value
    /// NOTE : DISPLAYCONFIG_VIDEO_SIGNAL_INFO.vSyncFreq is the Vsync rate between the Indirect Display device and the
    /// connected monitor.  DISPLAYCONFIG_VIDEO_SIGNAL_INFO.AdditionalSignalInfo.vSyncFreqDivider is used to
    /// calculate the rate at which the OS will update the desktop image.
    /// The desktop update rate will calculate be :
    ///    DISPLAYCONFIG_VIDEO_SIGNAL_INFO.vSyncFreq / DISPLAYCONFIG_VIDEO_SIGNAL_INFO.AdditionalSignalInfo.vSyncFreqDivider
    /// DISPLAYCONFIG_VIDEO_SIGNAL_INFO.AdditionalSignalInfo.vSyncFreqDivider cannot be zero
    /// </summary>
    DISPLAYCONFIG_VIDEO_SIGNAL_INFO TargetVideoSignalInfo;
};

struct IDARG_IN_COMMITMODES
{
    /// <summary>
    /// [in] The number of paths in the pPaths array
    /// </summary>
    UINT PathCount;

    /// <summary>
    /// [in] Point to the array of paths to be committed
    /// </summary>
    _Field_size_(PathCount) IDDCX_PATH* pPaths;
};

/// <summary>
/// Structure used to describe the cursor capabilities for a given path.
/// </summary>
struct IDDCX_CURSOR_CAPS
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// Indicates what level of support the driver has for XOR masks in the 32-bit masked color cursor format.
    /// NOTE : The OS will first convert any monochrome cursor to a color mask cursor.
    /// </summary>
    IDDCX_XOR_CURSOR_SUPPORT ColorXorCursorSupport;

    /// <summary>
    /// Indicates if the adapter supports the 32-bit alpha cursor format. Most cursors are alpha format.
    /// </summary>
    BOOL AlphaCursorSupport;

    /// <summary>
    /// The maximum width supported for all supported cursor types
    /// </summary>
    UINT MaxX;

    /// <summary>
    /// The maximum height support for all cursor types
    /// </summary>
    UINT MaxY;
};

struct IDARG_IN_SETUP_HWCURSOR
{
    /// <summary>
    /// [in] Cursor information for this path
    /// </summary>
    IDDCX_CURSOR_CAPS CursorInfo;

    /// <summary>
    /// [in] An event handle that will be triggered when new cursor data is available
    /// </summary>
    HANDLE hNewCursorDataAvailable;
};

/// <summary>
/// Describes the cursor shape
/// </summary>
struct IDDCX_CURSOR_SHAPE_INFO
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// Unique id for the current cursor image, this is incremented each time a cursor image is set (even if that image has been set before).
    /// This is used to check if the current cursor image the driver has cached has changed and cannot be used in any way to allow caching
    /// for animated cursor sequences.
    /// </summary>
    UINT ShapeId;

    /// <summary>
    /// Indicates the type of cursor data written to the cursor shape buffer
    /// </summary>
    IDDCX_CURSOR_SHAPE_TYPE CursorType;

    /// <summary>
    /// Width in pixels of the cursor shape written to the shape buffer
    /// </summary>
    UINT Width;

    /// <summary>
    /// Height in pixels of the cursor shape written to the shape buffer
    /// </summary>
    UINT Height;

    /// <summary>
    /// Pitch in bytes of the cursor shape written to the shape buffer
    /// </summary>
    UINT Pitch;

    /// <summary>
    /// X position of the cursor hotspot relative to the top-left of the cursor
    /// </summary>
    UINT XHot;

    /// <summary>
    /// Y position of the cursor hotspot relative to the top-left of the cursor
    /// </summary>
    UINT YHot;
};

struct IDARG_IN_QUERY_HWCURSOR
{
    /// <summary>
    /// [in] The shape id of the last cursor shape the driver received for this monitor, this is compared against the
    /// latest shape the OS has and the new shape is only copied to the buffer it OS version has been updated since
    /// last image driver received
    /// </summary>
    DWORD LastShapeId;

    /// <summary>
    /// [in] Size of the cursor shape buffer pShapeBuffer
    /// </summary>
    UINT ShapeBufferSizeInBytes;

    /// <summary>
    /// [out] Buffer provided by driver that the OS will copy any new cursor image data into
    /// </summary>
    _Field_size_bytes_(ShapeBufferSizeInBytes) PBYTE pShapeBuffer;
};

struct IDARG_OUT_QUERY_HWCURSOR
{
    /// <summary>
    /// [out] Indicates if the cursor is visible or not.
    /// </summary>
    BOOL IsCursorVisible;

    /// <summary>
    /// [out] If the cursor is viable then this is the screen co-ordinates of the top-left hand pixel in the cursor image.
    /// NOTE : This can be negative eg hot-spot in center of cursor and is placed in top-left of screen
    /// </summary>
    INT X;

    /// <summary>
    /// [out] If the cursor is viable then this is the screen co-ordinates of the top-left hand pixel in the cursor image.
    /// NOTE : This can be negative eg hot-spot in center of cursor and is placed in top-left of screen
    /// </summary>
    INT Y;

    /// <summary>
    /// [out] Indicates if the cursor shape has been updated since the last time the driver called, if it has been updated
    /// then the OS updated the CursorShapeInfo structure and also copied the new cursor image data into the
    /// IDARG_IN_QUERY_HWCURSOR.pShapeBuffer buffer
    /// </summary>
    BOOL IsCursorShapeUpdated;

    /// <summary>
    /// [out] If cursor visible then OS will copy the current cursor info into this buffer, if cursor is not visible then
    /// OS will zero this structure
    /// </summary>
    IDDCX_CURSOR_SHAPE_INFO CursorShapeInfo;
};

struct IDARG_IN_SETSWAPCHAIN
{
    /// <summary>
    /// [in] Handle to indirect swapchain that will be used to pass the desktop image to the driver
    /// for processing, transmission and display
    /// </summary>
    IDDCX_SWAPCHAIN hSwapChain;

    /// <summary>
    /// [in] Handle to auto reset event that is signaled when new image to encode is ready
    /// </summary>
    HANDLE hNextSurfaceAvailable;

    /// <summary>
    /// [In] Luid of the adapter were the desktop image was rendered
    /// </summary>
    LUID RenderAdapterLuid;
};

/// <summary>
/// Per frame meta-data
/// </summary>
struct IDDCX_METADATA
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// Presentation frame number of this surface, if the frame number is the same as the previous frame then
    /// that indicates that there has not been any image updates from the previous frame and is an opportunity
    /// for the driver to re-encode the desktop image again to increase the visual quality.
    /// Once there are no more updates the OS will present the same frame IDDCX_ADAPTER_CAPS.StaticDesktopReencodeFrameCount
    /// times (a presentation internals) and then stop presenting until the next update
    /// </summary>
    UINT PresentationFrameNumber;

    /// <summary>
    /// Number of dirty rects for this frame, call GetDirtyRects() to get the dirty rects
    /// NOTE : A zero DirtyRectCount and MoveRegionCount value indicates there were no desktop updates and the
    /// PresentationFrameNumber is the same as last frame
    /// </summary>
    UINT DirtyRectCount;

    /// <summary>
    /// Number of move regions in this frame, call GetMoveRegions() to get the move regions
    /// NOTE : A zero DirtyRectCount and MoveRegionCount value indicates there were no desktop updates and the
    /// PresentationFrameNumber is the same as last frame
    /// </summary>
    UINT MoveRegionCount;

    /// <summary>
    /// Indicates if the provided surface is hardware protected or not
    /// </summary>
    BOOL HwProtectedSurface;

    /// <summary>
    /// System QPC time of when this surface should be displayed on the indirect display monitor
    /// </summary>
    UINT64 PresentDisplayQPCTime;

    /// <summary>
    /// DX surface that contains the image to encode and transmit.
    /// The driver can use this DX surface anytime until ReleaseAndAcquire is called again
    /// NOTE : This surface is always a A8R8G8B8 formated surface
    /// </summary>
    IDXGIResource* pSurface;
};

struct IDARG_IN_SWAPCHAINSETDEVICE
{
    /// <summary>
    /// The DXGI device used to process swap-chain frames.
    /// </summary>
    IDXGIDevice* pDevice;
};

struct IDARG_OUT_RELEASEANDACQUIREBUFFER
{
    /// <summary>
    /// [out] Per-frame metadata and frame information
    /// </summary>
    IDDCX_METADATA MetaData;
};

struct IDARG_IN_GETDIRTYRECTS
{
    /// <summary>
    /// [in] Number of dirty rects in the pDirtyRects array
    /// </summary>
    UINT DirtyRectInCount;

    /// <summary>
    /// [out] Pointer to the buffer where the OS can copy the dirty rects that indicate which parts of the surface have been
    /// changed since the last present.
    /// </summary>
    _Field_size_full_(DirtyRectInCount) RECT* pDirtyRects;
};


struct IDARG_OUT_GETDIRTYRECTS
{
    /// <summary>
    /// [out] Number of dirty rects the OS copied into the pDirtyRects array
    /// </summary>
    UINT DirtyRectOutCount;
};

/// <summary>
/// Describes a move region within a surface
/// </summary>
struct IDDCX_MOVEREGION
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// The location within the surface of the top left of the source rect, the source rect size is the same as the
    /// destination rect size
    /// </summary>
    POINT SourcePoint;

    /// <summary>
    /// Defines the destination rect of the move
    /// </summary>
    RECT DestRect;
};

struct IDARG_IN_GETMOVEREGIONS
{
    /// <summary>
    /// [in] Number of move regions in the pMoveRegions array
    /// </summary>
    UINT MoveRegionInCount;

    /// <summary>
    /// [out] Pointer to the buffer where the OS can copy the move regions
    /// </summary>
    _Field_size_full_(MoveRegionInCount) IDDCX_MOVEREGION* pMoveRegions;
};


struct IDARG_OUT_GETMOVEREGIONS
{
    /// <summary>
    /// [out] Number of move regions the OS copied into the pMoveRegions array
    /// </summary>
    UINT MoveRegionOutCount;
};

/// <summary>
/// Defines a single step of the frame processing
/// </summary>
struct IDDCX_FRAME_STATISTICS_STEP
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// The type of frame processing step
    /// </summary>
    IDDCX_FRAME_STATISTICS_STEP_TYPE Type;

    /// <summary>
    /// Provides the system QPC time of the step
    /// </summary>
    UINT64 QpcTime;

    /// <summary>
    /// When driver defined processing part is used then driver can store additional data here
    /// </summary>
    UINT32 Data[2];
};

/// <summary>
/// Holds the frame processing statics for a whole frame
/// </summary>
struct IDDCX_FRAME_STATISTICS
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// The frame number provided in the ReleaseAndAcquireBuffer call
    /// </summary>
    UINT PresentationFrameNumber;

    /// <summary>
    /// Indicates the overall status of processing this frame
    /// </summary>
    IDDCX_FRAME_STATUS FrameStatus;

    /// <summary>
    /// Zero based number to indicates the number of times the same frame has been encoded and sent.
    /// Re-encodes can be the result of the OS providing the sane frame (and frame number) to the driver to
    /// encode or the driver having to re-encode outside of the normal OS presentation to satisfy the
    /// protocol
    /// </summary>
    UINT ReEncodeNumber;

    /// <summary>
    /// Indicates the number of slices the driver processes the frame in, if slices are not used
    /// then this should be set to the value one
    /// </summary>
    UINT FrameSliceTotal;

    /// <summary>
    /// Indicates the zero based slice number being reported, if slicing is not supported then the driver
    /// should always set this to the value zero
    /// </summary>
    UINT CurrentSlice;

    /// <summary>
    /// System Qpc time the driver acquired the buffer from the OS
    /// </summary>
    UINT64 FrameAcquireQpcTime;

    /// <summary>
    /// The size of the frame step array pointed to by pFrameParts
    /// </summary>
    UINT FrameProcessingStepsCount;

    /// <summary>
    /// Array of frame processing steps the driver performed
    /// </summary>
    _Field_size_(FrameProcessingStepsCount) IDDCX_FRAME_STATISTICS_STEP* pFrameProcessingStep;

    /// <summary>
    /// Marks the time when the driver started transmission for this slice to the device
    /// NOTE : This marks the time the driver started calling the transmit API's not when the data actually starts being transmitted
    /// </summary>
    UINT64 SendStartQpcTime;

    /// <summary>
    /// Marks the time when the driver started transmission for this slice to the device
    /// NOTE : This marks the time the driver started calling the transmit API's not when the data actually starts being transmitted
    /// </summary>
    UINT64 SendStopQpcTime;

    /// <summary>
    /// Marks the time when the send was reported as complete by the OS
    /// This is a optional time stamp that can be used if the driver uses asynchronous transmit API and uses a completion routine
    /// in the event the driver does not have a asynchronous completion routine should set this value to zero
    /// </summary>
    UINT64 SendCompleteQpcTime;

    IDDCX_FRAME_STATISTICS_FLAGS Flags;

    /// <summary>
    /// The total number of pixels processed in this frame
    /// </summary>
    UINT ProcessedPixelCount;

    /// <summary>
    /// Total size of the data send to device for this frame, this includes all the slices
    /// </summary>
    UINT FrameSizeInBytes;
};

/// <summary>
/// Either IDDCX_SWAPCHAIN is a handle so we know when it is invalid or we have a driver callback
/// when the swapchain is destroyed so driver knows not to call this callback.
/// Need this resolve for the other swapchain callbacks as well
/// </summary>
struct IDARG_IN_REPORTFRAMESTATISTICS
{
    /// <summary>
    /// [in] Frame statics being reported
    /// </summary>
    IDDCX_FRAME_STATISTICS FrameStatistics;
};

struct IDARG_IN_I2C_TRANSMIT
{
    /// <summary>
    /// [in] The address of the I2C device from which data will be transmitted
    /// </summary>
    UINT SevenBitI2CAddress;

    /// <summary>
    /// [in] The size, in bytes, of the buffer pointed to by pData, this parameter must be between 1 and 64, inclusive
    /// </summary>
    UINT DataSizeInBytes;

    /// <summary>
    /// [in] A pointer to a buffer that holds the data to be transmitted
    /// </summary>
    _Field_size_full_(DataSizeInBytes) PVOID pData;
};

struct IDARG_IN_SET_GAMMARAMP
{
    /// <summary>
    /// [in] The type of gamma ramp being set
    /// </summary>
    IDDCX_GAMMARAMP_TYPE Type;

    /// <summary>
    /// [in] Size in bytes of the provided gamma ramp data.  Set to zero for IDDCX_GAMMARAMP_TYPE_DEFAULT
    /// </summary>
    UINT GammaRampSizeInBytes;

    /// <summary>
    /// [in] Pointer to gamma ramp data to set.  Set to NULL for IDDCX_GAMMARAMP_TYPE_DEFAULT
    /// </summary>
    _Field_size_bytes_opt_(GammaRampSizeInBytes) PVOID pGammaRampData;
};

struct IDARG_IN_I2C_RECEIVE
{
    /// <summary>
    /// [in] The address of the I2C device from which data will be received
    /// </summary>
    UINT SevenBitI2CAddress;

    /// <summary>
    /// [in] Flags for the receive operation
    /// </summary>
    UINT Flags;

    /// <summary>
    /// [in] The size, in bytes, of the buffer pointed to by pData
    /// </summary>
    UINT DataSizeInBytes;

    /// <summary>
    /// [out] A pointer to a buffer that receives the data.
    /// </summary>
    _Field_size_full_(DataSizeInBytes) PVOID pData;
};

struct IDARG_IN_OPM_GET_CERTIFICATE_SIZE
{
    /// <summary>
    /// [in] Type of certificate the size request is for
    /// </summary>
    OPM_VIDEO_OUTPUT_SEMANTICS CertificateType;
};

struct IDARG_OUT_OPM_GET_CERTIFICATE_SIZE
{
    /// <summary>
    /// [out] Size of certificate
    /// </summary>
    UINT CertificateSize;
};

struct IDARG_IN_OPM_GET_CERTIFICATE
{
    /// <summary>
    /// [in] Type of certificate the size request is for
    /// </summary>
    OPM_VIDEO_OUTPUT_SEMANTICS CertificateType;

    /// <summary>
    /// [in] Size of the buffer provided for the driver to copy the certificate to
    /// </summary>
    UINT CertificateBufferSizeInBytes;

    /// <summary>
    /// [out] A pointer to a buffer that the driver copies the certificate to.
    /// </summary>
    _Field_size_full_(CertificateBufferSizeInBytes) PVOID pCertificate;
};

struct IDARG_IN_OPM_CREATE_PROTECTED_OUTPUT
{
    /// <summary>
    /// [in] Type of semantics for this context
    /// </summary>
    OPM_VIDEO_OUTPUT_SEMANTICS VideoOutputSemantics;
};

struct IDDCX_OPM_GET_RANDOM_NUMBER
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// The random number the driver generated
    /// </summary>
    OPM_RANDOM_NUMBER RandomNumber;
};

struct IDARG_OUT_OPM_GET_RANDOM_NUMBER
{
    /// <summary>
    /// [out] The random number the driver generated
    /// </summary>
    IDDCX_OPM_GET_RANDOM_NUMBER RandomNumber;
};

struct IDDCX_OPM_ENCRYPTED_INITIALIZATION_PARAMETERS
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// Initialization parameters
    /// </summary>
    OPM_ENCRYPTED_INITIALIZATION_PARAMETERS EncryptedParameters;
};

struct IDARG_IN_OPM_SET_SIGNING_KEY_AND_SEQUENCE_NUMBERS
{
    /// <summary>
    /// [in] Initialization parameters
    /// </summary>
    IDDCX_OPM_ENCRYPTED_INITIALIZATION_PARAMETERS EncryptedParameters;
};

struct IDDCX_OPM_GET_INFO_PARAMETERS
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// Parameters for the get information request
    /// </summary>
    OPM_GET_INFO_PARAMETERS GetInfoParameters;
};

struct IDARG_IN_OPM_GET_INFOMATION
{
    /// <summary>
    /// [in] Parameters for the get information request
    /// </summary>
    IDDCX_OPM_GET_INFO_PARAMETERS GetInfoParameters;
};

struct IDDCX_OPM_REQUESTED_INFORMATION
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// The information that was requested
    /// </summary>
    OPM_REQUESTED_INFORMATION RequestedInformation;
};

struct IDARG_OUT_OPM_GET_INFOMATION
{
    /// <summary>
    /// [out] The information that was requested
    /// </summary>
    IDDCX_OPM_REQUESTED_INFORMATION RequestedInformation;
};

struct IDDCX_OPM_CONFIGURE_PARAMETERS
{
    /// <summary>
    /// Total size of the structure
    /// </summary>
    UINT Size;

    /// <summary>
    /// Configuration parameters
    /// </summary>
    OPM_CONFIGURE_PARAMETERS ConfigParameters;
};

struct IDARG_IN_OPM_CONFIGURE_PROTECTED_OUTPUT
{
    /// <summary>
    /// [in] Configuration parameters
    /// </summary>
    IDDCX_OPM_CONFIGURE_PARAMETERS ConfigParameters;

    /// <summary>
    /// [in] Size of additional parameter buffer
    /// </summary>
    UINT AdditionalParametersSizeInBytes;

    /// <summary>
    /// [in] A pointer to a buffer that the driver copies the certificate to.
    /// </summary>
    _Field_size_full_(AdditionalParametersSizeInBytes) PVOID pAdditionalParameters;
};

struct IDARG_OUT_GETVERSION
{
    /// <summary>
    /// [out] Configuration parameters
    /// </summary>
    ULONG IddCxVersion;
};

struct IDARG_IN_REPORTCRITICALERROR
{
    /// <summary>
    /// [In] The major error code for this critical error.  Valid range 0-0xff inclusive
    /// </summary>
    ULONG MajorErrorCode;

    /// <summary>
    /// [In] The minor error code for this critical error.  Valid range 0-0xff inclusive
    /// </summary>
    ULONG MinorErrorCode;
};

struct IDARG_IN_SETSRMLIST
{
    /// <summary>
    /// [in] The size, in bytes, of the buffer pointed to by pSrmList
    /// </summary>
    UINT SrmListSizeInBytes;

    /// <summary>
    /// [in] A pointer to a buffer that holds the SRM list to pass to the appropriate
    /// Wddm driver. This buffer should contain the SRM in the format required by
    /// Digital Content Protection LLC for HDCP
    /// </summary>
    _Field_size_full_(SrmListSizeInBytes) PVOID pSrmList;
};

struct IDARG_IN_GETSRMLISTVERSION
{
    /// <summary>
    /// [in] The size in bytes of the pSrmListVerion being passed by driver to the OS
    /// A value of zero indicates that the driver is just querying the size of
    /// the SRM list version buffer that should be provided by the driver, in
    /// this case the OS will set buffer size in the output structure.
    /// Either SrmListVersionBufferInputCount needs to be zero and pSrmListVerion
    /// set to null or SrmListVersionBufferInputCount needs to be non-zero and
    /// pSrmListVerion needs to be non-null
    /// </summary>
    UINT SrmListVersionBufferInputCount;

    /// <summary>
    /// [out] Pointer to buffer that OS should copy the SRM list version to if
    /// the value is non-NULL.  In this case the format of the version is defined by
    /// the PlayReady Porting Kit 4.0.
    /// If value is NULL then OS will not copy any data and OS will set the value
    /// IDARG_OUT_GETSRMLISTVERSION.SrmListVersionBufferOutputCount to indicate
    /// the size of buffer required to store the SRM list version
    /// </summary>
    _Field_size_opt_(SrmListVersionBufferInputCount) PVOID pSrmListVerion;
};

struct IDARG_OUT_GETSRMLISTVERSION
{
    /// <summary>
    /// [out] If IDARG_IN_GETSRMLISTVERSION.pSrmListVerion was NULL then OS will
    /// set this to the size of the buffer necessary to read the SRM list version
    /// description.
    /// If IDARG_IN_GETSRMLISTVERSION.pSrmListVerion was non-NULL then this
    /// is the number of bytes returned in
    /// IDARG_IN_GETSRMLISTVERSION.pSrmListVerion buffer
    /// If there was no SRM list set then SrmListVersionBufferOutputCount will be
    /// set to zero.
    /// </summary>
    UINT SrmListVersionBufferOutputCount;
};

#pragma endregion

#pragma region Structure Initialization

VOID
FORCEINLINE
IDD_CX_CLIENT_CONFIG_INIT(
    _Out_ IDD_CX_CLIENT_CONFIG* Config
    )
{
    RtlZeroMemory(Config, sizeof(IDD_CX_CLIENT_CONFIG));
    Config->Size = sizeof(IDD_CX_CLIENT_CONFIG);
}

#pragma endregion

#pragma region Indirect Display APIs

//
// IDD Function: IddCxDeviceInitConfig
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(*PFN_IDDCXDEVICEINITCONFIG)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _Inout_
    PWDFDEVICE_INIT DeviceInit,
    _In_
    CONST IDD_CX_CLIENT_CONFIG* Config
    );

/// <summary>
/// Inits a WDFDEVICE initialization structure to allow indirect displays to be used.
/// </summary>
_Must_inspect_result_
NTSTATUS
FORCEINLINE
IddCxDeviceInitConfig(
    _Inout_
    PWDFDEVICE_INIT DeviceInit,
    _In_
    CONST IDD_CX_CLIENT_CONFIG* Config
    )
{
    return ((PFN_IDDCXDEVICEINITCONFIG) IddFunctions[IddCxDeviceInitConfigTableIndex])(IddDriverGlobals, DeviceInit, Config);
}

//
// IDD Function: IddCxDeviceInitialize
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(*PFN_IDDCXDEVICEINITIALIZE)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    WDFDEVICE Device
    );

/// <summary>
/// Initializes a WDF device
/// </summary>
_Must_inspect_result_
NTSTATUS
FORCEINLINE
IddCxDeviceInitialize(
    _In_
    WDFDEVICE Device
    )
{
    return ((PFN_IDDCXDEVICEINITIALIZE) IddFunctions[IddCxDeviceInitializeTableIndex])(IddDriverGlobals, Device);
}

//
// IDD Function: IddCxAdapterInitAsync
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(*PFN_IDDCXADAPTERINITASYNC)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    CONST IDARG_IN_ADAPTER_INIT* pInArgs,
    _Out_
    IDARG_OUT_ADAPTER_INIT* pOutArgs
    );

/// <summary>
/// This will be called by driver to create a WDDM graphics adapter
/// </summary>
/// <param name="hDriverAdapterContext">The handle the driver provides so the OS can reference this adapter when calling the driver</param>
/// <param name="pInArgs">Input arguments to the function</param>
/// <param name="pOutArgs">Output arguments to the function</param>
/// <returns>If the routine succeeds it return S_OK otherwise an appropriate error code</returns>
_Must_inspect_result_
NTSTATUS
FORCEINLINE
IddCxAdapterInitAsync(
    _In_
    CONST IDARG_IN_ADAPTER_INIT* pInArgs,
    _Out_
    IDARG_OUT_ADAPTER_INIT* pOutArgs
    )
{
    return ((PFN_IDDCXADAPTERINITASYNC) IddFunctions[IddCxAdapterInitAsyncTableIndex])(IddDriverGlobals, pInArgs, pOutArgs);
}

//
// IDD Function: IddCxMonitorCreate
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(*PFN_IDDCXMONITORCREATE)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_ADAPTER AdapterObject,
    _In_
    CONST IDARG_IN_MONITORCREATE* pInArgs,
    _Out_
    IDARG_OUT_MONITORCREATE* pOutArgs
    );

/// <summary>
/// An OS callback function the driver calls to create a monitor object that can later be used for arrival.
/// </summary>
/// <param name="AdapterObject">The adapter object that is hosting the newly arrived monitor</param>
/// <param name="pInArgs">Input arguments to the function</param>
/// <param name="pOutArgs">Output arguments to the function</param>
/// <returns>
/// If the routine succeeds it return STATUS_SUCCESS otherwise it returns one the follwing error codes:
/// STATUS_MONITOR_NO_DESCRIPTOR - Only DisplayID is present, but no EDID
/// STATUS_MONITOR_INVALID_DESCRIPTOR_CHECKSUM - DisplayID checksum is incorrect
/// STATUS_NOT_SUPPORTED - Too many target modes
/// </returns>
_Must_inspect_result_
NTSTATUS
FORCEINLINE
IddCxMonitorCreate(
    _In_
    IDDCX_ADAPTER AdapterObject,
    _In_
    CONST IDARG_IN_MONITORCREATE* pInArgs,
    _Out_
    IDARG_OUT_MONITORCREATE* pOutArgs
    )
{
    return ((PFN_IDDCXMONITORCREATE) IddFunctions[IddCxMonitorCreateTableIndex])(IddDriverGlobals, AdapterObject, pInArgs, pOutArgs);
}

//
// IDD Function: IddCxMonitorArrival
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(*PFN_IDDCXMONITORARRIVAL)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_MONITOR AdapterObject,
    _Out_
    IDARG_OUT_MONITORARRIVAL* pOutArgs
    );

/// <summary>
/// An OS callback function the driver calls report a monitor arrival on the WDDM graphics adapter
/// </summary>
/// <param name="AdapterObject">The adapter object that is hosting the newly arrived monitor</param>
/// <param name="pInArgs">Input arguments to the function</param>
/// <param name="pOutArgs">Output arguments to the function</param>
/// <returns>If the routine succeeds it return S_OK otherwise an appropriate error code</returns>
_Must_inspect_result_
NTSTATUS
FORCEINLINE
IddCxMonitorArrival(
    _In_
    IDDCX_MONITOR AdapterObject,
    _Out_
    IDARG_OUT_MONITORARRIVAL* pOutArgs
    )
{
    return ((PFN_IDDCXMONITORARRIVAL) IddFunctions[IddCxMonitorArrivalTableIndex])(IddDriverGlobals, AdapterObject, pOutArgs);
}

//
// IDD Function: IddCxMonitorDeparture
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(*PFN_IDDCXMONITORDEPARTURE)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_MONITOR MonitorObject
    );

/// <summary>
/// An OS callback function the driver calls report a monitor departure from the WDDM graphics adapter
/// </summary>
/// <param name="MonitorObject">The monitor object that is departing</param>
/// <param name="pInArgs">Input arguments to the function</param>
/// <returns>If the routine succeeds it return S_OK otherwise an appropriate error code</returns>
_Must_inspect_result_
NTSTATUS
FORCEINLINE
IddCxMonitorDeparture(
    _In_
    IDDCX_MONITOR MonitorObject
    )
{
    return ((PFN_IDDCXMONITORDEPARTURE) IddFunctions[IddCxMonitorDepartureTableIndex])(IddDriverGlobals, MonitorObject);
}

//
// IDD Function: IddCxMonitorUpdateModes
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(*PFN_IDDCXMONITORUPDATEMODES)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_UPDATEMODES* pInArgs
    );

/// <summary>
/// An OS callback function the driver calls to update the mode list
/// </summary>
/// <param name="MonitorObject">The monitor object being updated</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>If the routine succeeds it return S_OK otherwise an appropriate error code</returns>
_Must_inspect_result_
NTSTATUS
FORCEINLINE
IddCxMonitorUpdateModes(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_UPDATEMODES* pInArgs
    )
{
    return ((PFN_IDDCXMONITORUPDATEMODES) IddFunctions[IddCxMonitorUpdateModesTableIndex])(IddDriverGlobals, MonitorObject, pInArgs);
}

//
// IDD Function: IddCxAdapterUpdateMaxDisplayPipelineRate
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(*PFN_IDDCXADAPTERUPDATEMAXDISPLAYPIPELINERATE)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_ADAPTER hOsAdapterContext,
    _In_
    CONST IDARG_IN_MAXDISPLAYPIPELINERATE* pInArgs
    );

/// <summary>
/// An OS callback function the driver calls report that the max display pipeline rate has changed
/// </summary>
/// <param name="hOsAdapterContext">This is the OS context handle for this adapter returned by the IddCxSTart call</param>
/// <param name="pInArgs">Input arguments to the function</param>
/// <param name="pOutArgs">Output arguments to the function</param>
/// <returns>If the routine succeeds it return S_OK otherwise an appropriate error code</returns>
_Must_inspect_result_
NTSTATUS
FORCEINLINE
IddCxAdapterUpdateMaxDisplayPipelineRate(
    _In_
    IDDCX_ADAPTER hOsAdapterContext,
    _In_
    CONST IDARG_IN_MAXDISPLAYPIPELINERATE* pInArgs
    )
{
    return ((PFN_IDDCXADAPTERUPDATEMAXDISPLAYPIPELINERATE) IddFunctions[IddCxAdapterUpdateMaxDisplayPipelineRateTableIndex])(IddDriverGlobals, hOsAdapterContext, pInArgs);
}

//
// IDD Function: IddCxMonitorSetupHardwareCursor
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(*PFN_IDDCXMONITORSETUPHARDWARECURSOR)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_SETUP_HWCURSOR* pInArgs
    );

/// <summary>
/// An OS callback function the driver calls when it wants to setup hardware cursor support for the path.  By default when a
/// mode is committed on a path software cursor is enabled, if the driver want to accelerate the cursor on that path it uses
/// this callback to enable hardware cursor support
/// </summary>
/// <param name="MonitorObject">The handle the OS provided to identify the monitor</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>
/// If the routine succeeds it return S_OK otherwise an appropriate error code.
/// </returns>
_Must_inspect_result_
NTSTATUS
FORCEINLINE
IddCxMonitorSetupHardwareCursor(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_SETUP_HWCURSOR* pInArgs
    )
{
    return ((PFN_IDDCXMONITORSETUPHARDWARECURSOR) IddFunctions[IddCxMonitorSetupHardwareCursorTableIndex])(IddDriverGlobals, MonitorObject, pInArgs);
}

//
// IDD Function: IddCxMonitorQueryHardwareCursor
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(*PFN_IDDCXMONITORQUERYHARDWARECURSOR)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_QUERY_HWCURSOR* pInArgs,
    _Out_
    IDARG_OUT_QUERY_HWCURSOR* pOutArgs
    );

/// <summary>
/// An OS callback function the driver calls when it wants obtain the updated cursor information, driver normally only calls
/// this when the event that signals cursor update has triggered
/// </summary>
/// <param name="MonitorObject">This is the OS context handle for this monitor returned by the IddCxMonitorArrival call</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>
/// If the routine succeeds it return S_OK otherwise an appropriate error code.
/// </returns>
_Must_inspect_result_
NTSTATUS
FORCEINLINE
IddCxMonitorQueryHardwareCursor(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    CONST IDARG_IN_QUERY_HWCURSOR* pInArgs,
    _Out_
    IDARG_OUT_QUERY_HWCURSOR* pOutArgs
    )
{
    return ((PFN_IDDCXMONITORQUERYHARDWARECURSOR) IddFunctions[IddCxMonitorQueryHardwareCursorTableIndex])(IddDriverGlobals, MonitorObject, pInArgs, pOutArgs);
}

//
// IDD Function: IddCxSwapChainSetDevice
//
typedef
_Must_inspect_result_
WDFAPI
HRESULT
(*PFN_IDDCXSWAPCHAINSETDEVICE)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _In_
    IDARG_IN_SWAPCHAINSETDEVICE* pInArgs
    );

/// <summary>
/// An OS callback function the driver calls within its SetSwapChain routine to setup the swap-chain with a particular DXGI device.
/// </summary>
_Must_inspect_result_
HRESULT
FORCEINLINE
IddCxSwapChainSetDevice(
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _In_
    IDARG_IN_SWAPCHAINSETDEVICE* pInArgs
    )
{
    return ((PFN_IDDCXSWAPCHAINSETDEVICE) IddFunctions[IddCxSwapChainSetDeviceTableIndex])(IddDriverGlobals, SwapChainObject, pInArgs);
}

//
// IDD Function: IddCxSwapChainReleaseAndAcquireBuffer
//
typedef
_Must_inspect_result_
WDFAPI
HRESULT
(*PFN_IDDCXSWAPCHAINRELEASEANDACQUIREBUFFER)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _Out_
    IDARG_OUT_RELEASEANDACQUIREBUFFER* pOutArgs
    );

/// <summary>
/// An OS callback function the driver calls when it wants to release the current buffer in the swapchain and acquire a new one
/// The OS singles the IDARG_IN_SETSWAPCHAIN.hNextSurfaceAvailable event when the next buffer is ready to acquire.
/// </summary>
/// <param name="SwapChainObject">The swap-chain object passed to the EVT_IDD_CX_MONITOR_SET_SWAPCHAIN call.</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>
/// If the routine succeeds it return S_OK otherwise an appropriate error code.
/// E_PENDING indicates that there was not a new buffer to acquire, this should not occur if driver is only calling after the event is signaled
/// </returns>
_Must_inspect_result_
HRESULT
FORCEINLINE
IddCxSwapChainReleaseAndAcquireBuffer(
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _Out_
    IDARG_OUT_RELEASEANDACQUIREBUFFER* pOutArgs
    )
{
    return ((PFN_IDDCXSWAPCHAINRELEASEANDACQUIREBUFFER) IddFunctions[IddCxSwapChainReleaseAndAcquireBufferTableIndex])(IddDriverGlobals, SwapChainObject, pOutArgs);
}

//
// IDD Function: IddCxSwapChainGetDirtyRects
//
typedef
_Must_inspect_result_
WDFAPI
HRESULT
(*PFN_IDDCXSWAPCHAINGETDIRTYRECTS)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _In_
    CONST IDARG_IN_GETDIRTYRECTS* pInArgs,
    _Out_
    IDARG_OUT_GETDIRTYRECTS* pOutArgs
    );

/// <summary>
/// An OS callback function the driver calls when it wants retrieve the dirty rects for the current frame
/// </summary>
/// <param name="SwapChainObject">The swap-chain object whose current frame is being queried.</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>
/// If the routine succeeds it return S_OK otherwise an appropriate error code.
/// </returns>
_Must_inspect_result_
HRESULT
FORCEINLINE
IddCxSwapChainGetDirtyRects(
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _In_
    CONST IDARG_IN_GETDIRTYRECTS* pInArgs,
    _Out_
    IDARG_OUT_GETDIRTYRECTS* pOutArgs
    )
{
    return ((PFN_IDDCXSWAPCHAINGETDIRTYRECTS) IddFunctions[IddCxSwapChainGetDirtyRectsTableIndex])(IddDriverGlobals, SwapChainObject, pInArgs, pOutArgs);
}

//
// IDD Function: IddCxSwapChainGetMoveRegions
//
typedef
_Must_inspect_result_
WDFAPI
HRESULT
(*PFN_IDDCXSWAPCHAINGETMOVEREGIONS)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _In_
    CONST IDARG_IN_GETMOVEREGIONS* pInArgs,
    _Out_
    IDARG_OUT_GETMOVEREGIONS* pOutArgs
    );

/// <summary>
/// An OS callback function the driver calls when it wants retrieve the move regions for the current frame
/// </summary>
/// <param name="SwapChainObject">The swap-chain object whose current frame is being queried.</param>
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>
/// If the routine succeeds it return S_OK otherwise an appropriate error code.
/// </returns>
_Must_inspect_result_
HRESULT
FORCEINLINE
IddCxSwapChainGetMoveRegions(
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _In_
    CONST IDARG_IN_GETMOVEREGIONS* pInArgs,
    _Out_
    IDARG_OUT_GETMOVEREGIONS* pOutArgs
    )
{
    return ((PFN_IDDCXSWAPCHAINGETMOVEREGIONS) IddFunctions[IddCxSwapChainGetMoveRegionsTableIndex])(IddDriverGlobals, SwapChainObject, pInArgs, pOutArgs);
}

//
// IDD Function: IddCxSwapChainFinishedProcessingFrame
//
typedef
_Must_inspect_result_
WDFAPI
HRESULT
(*PFN_IDDCXSWAPCHAINFINISHEDPROCESSINGFRAME)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_SWAPCHAIN SwapChainObject
    );

/// <summary>
/// An OS callback function the driver calls report all GPU command for processing this frame have been queue
/// For example if the driver copies the buffer to a staging surface so it can lock and copy the
/// pixel data to the CPU then the driver should call this callback once the copy from surface to staging surface
/// has been submitted (eg Dxgi CopyResource API called)
/// If the driver does not call this callback the desktop will not update, it is invalid to call ReleaseAndAcquireBuffer()
/// before calling FinishedProcessingFrame
/// </summary>
/// <param name="SwapChainObject">The swap-chain object whose current frame is being queried.</param>
/// <returns>If the routine succeeds it return S_OK otherwise an appropriate error code.</returns>
_Must_inspect_result_
HRESULT
FORCEINLINE
IddCxSwapChainFinishedProcessingFrame(
    _In_
    IDDCX_SWAPCHAIN SwapChainObject
    )
{
    return ((PFN_IDDCXSWAPCHAINFINISHEDPROCESSINGFRAME) IddFunctions[IddCxSwapChainFinishedProcessingFrameTableIndex])(IddDriverGlobals, SwapChainObject);
}

//
// IDD Function: IddCxSwapChainReportFrameStatistics
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(*PFN_IDDCXSWAPCHAINREPORTFRAMESTATISTICS)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _In_
    CONST IDARG_IN_REPORTFRAMESTATISTICS* pInArgs
    );

/// <summary>
/// An OS callback function the driver calls report the frame statics after it has processed a frame completely
/// </summary>
/// <param name="SwapChainObject">The swap-chain object whose current frame is being queried.</param>
/// <param name="pInArgs">Input arguments to the function</param>
/// <param name="pOutArgs">Output arguments to the function</param>
/// <returns>If the routine succeeds it return S_OK otherwise an appropriate error code</returns>
_Must_inspect_result_
NTSTATUS
FORCEINLINE
IddCxSwapChainReportFrameStatistics(
    _In_
    IDDCX_SWAPCHAIN SwapChainObject,
    _In_
    CONST IDARG_IN_REPORTFRAMESTATISTICS* pInArgs
    )
{
    return ((PFN_IDDCXSWAPCHAINREPORTFRAMESTATISTICS) IddFunctions[IddCxSwapChainReportFrameStatisticsTableIndex])(IddDriverGlobals, SwapChainObject, pInArgs);
}

//
// IDD Function: IddCxGetVersion
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(*PFN_IDDCXGETVERSION)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _Out_
    IDARG_OUT_GETVERSION* pOutArgs
    );

/// <summary>
/// An OS callback function the driver calls to find the IddCx version
/// </summary>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>
/// If the routine succeeds it return S_OK otherwise an appropriate error code.
/// </returns>
_Must_inspect_result_
NTSTATUS
FORCEINLINE
IddCxGetVersion(
    _Out_
    IDARG_OUT_GETVERSION* pOutArgs
    )
{
    return ((PFN_IDDCXGETVERSION) IddFunctions[IddCxGetVersionTableIndex])(IddDriverGlobals, pOutArgs);
}

//
// IDD Function: IddCxReportCriticalError
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(*PFN_IDDCXREPORTCRITICALERROR)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_opt_
    IDDCX_ADAPTER AdapterObject,
    _In_
    IDARG_IN_REPORTCRITICALERROR* pInArgs
    );

/// <summary>
/// An OS callback function the driver calls to report a critical error.
/// The OS will bugcheck the driver will the following bugcheck code :
///        (pInArgs->MajorErrorCode+0x100 << 8) + pInArgs->MinorErrorCode
/// Wastson dump will be generated and driver process will terminate and restart
/// according the UMDF driver restart policy.
/// As a user mode memory dump is generated the driver should place any useful
/// debug info on the stack of the function that calls this callback
/// </summary>
/// <param name>
/// <param name="AdapterObject">The adapter object that is the critical error occurred on
/// If the error occurred before a IddCxAdapter was created pass in nullptr</param>
/// <param name="pInArgs">Input arguments to the function</param>
/// <returns>
/// If the routine succeeds it never returns to the driver as the driver process will be
/// terminated
/// </returns>
_Must_inspect_result_
NTSTATUS
FORCEINLINE
IddCxReportCriticalError(
    _In_opt_
    IDDCX_ADAPTER AdapterObject,
    _In_
    IDARG_IN_REPORTCRITICALERROR* pInArgs
    )
{
    return ((PFN_IDDCXREPORTCRITICALERROR) IddFunctions[IddCxReportCriticalErrorTableIndex])(IddDriverGlobals, AdapterObject, pInArgs);
}

//
// IDD Function: IddCxMonitorSetSrmList
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(*PFN_IDDCXMONITORSETSRMLIST)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    IDARG_IN_SETSRMLIST* pInArgs
    );

/// <summary>
/// An OS callback function the driver calls when it wants pass a HDCP SRM list to
/// the GPU driver associated with the rendering of the specified monitor
/// </summary>
/// <param name="MonitorObject">The monitor object that the SRM list is associated with
/// <param name="pInArgs">Input arguments of function</param>
/// <returns>
/// If the routine succeeds it returns STATUS_SUCCESS otherwise an appropriate error
/// code.
/// STATUS_GRAPHICS_OPM_NOT_SUPPORTED will be returned if the GPU driver does not
/// support this new functionality.
/// STATUS_GRAPHICS_OPM_INVALID_SRM will be returned if the GPU driver does
/// recognize the format of the SRM list, this include if the driver detected
/// the list had been tampered with
/// </returns>
_Must_inspect_result_
NTSTATUS
FORCEINLINE
IddCxMonitorSetSrmList(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    IDARG_IN_SETSRMLIST* pInArgs
    )
{
    return ((PFN_IDDCXMONITORSETSRMLIST) IddFunctions[IddCxMonitorSetSrmListTableIndex])(IddDriverGlobals, MonitorObject, pInArgs);
}

//
// IDD Function: IddCxMonitorGetSrmListVersion
//
typedef
_Must_inspect_result_
WDFAPI
NTSTATUS
(*PFN_IDDCXMONITORGETSRMLISTVERSION)(
    _In_
    PIDD_DRIVER_GLOBALS DriverGlobals,
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    IDARG_IN_GETSRMLISTVERSION* pInArgs,
    _Out_
    IDARG_OUT_GETSRMLISTVERSION* pOutArgs
    );

/// <summary>
/// An OS callback function the driver calls when it wants to retrieve the latest SRM
/// list version stored by the GPU
/// </summary>
/// <param name="MonitorObject">The monitor object that the SRM list is associated with
/// <param name="pInArgs">Input arguments of function</param>
/// <param name="pOutArgs">Output arguments of function</param>
/// <returns>
/// If the routine succeeds it returns STATUS_SUCCESS otherwise an appropriate error
/// code.
/// STATUS_GRAPHICS_OPM_NOT_SUPPORTED will be returned if the GPU driver does not
/// support this new functionality.
/// STATUS_NO_DATA_DETECTED will be returned if the GPU does not have a current SRM
/// list
/// STATUS_BUFFER_TOO_SMALL will be return if the passed in buffer is too small
/// </returns>
_Must_inspect_result_
NTSTATUS
FORCEINLINE
IddCxMonitorGetSrmListVersion(
    _In_
    IDDCX_MONITOR MonitorObject,
    _In_
    IDARG_IN_GETSRMLISTVERSION* pInArgs,
    _Out_
    IDARG_OUT_GETSRMLISTVERSION* pOutArgs
    )
{
    return ((PFN_IDDCXMONITORGETSRMLISTVERSION) IddFunctions[IddCxMonitorGetSrmListVersionTableIndex])(IddDriverGlobals, MonitorObject, pInArgs, pOutArgs);
}



#pragma endregion

WDF_EXTERN_C_END

#endif // _IDDCX_H_

